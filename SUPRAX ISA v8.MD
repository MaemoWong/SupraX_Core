ğŸš€ SUPRAX ISA v8.2 - COMPLETE SPECIFICATION
ğŸ“ ARCHITECTURAL OVERVIEW
Core Parameters
apache
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ SUPRAX ISA - Fundamental Characteristics                                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘  Instruction Width:     128 bits (16 bytes) FIXED                       â•‘
â•‘  Opcode Size:           32 bits (6-bit type + 26-bit extended)          â•‘
â•‘  Register File:         256 architectural registers (r0-r255)           â•‘
â•‘  Register Addressing:   8 bits                                          â•‘
â•‘  Physical Registers:    3072 (12:1 rename ratio)                        â•‘
â•‘  Immediate Width:       Up to 64 bits (type-dependent)                  â•‘
â•‘  Memory Addressing:     64-bit flat address space                       â•‘
â•‘  Alignment:             All instructions 16-byte aligned                â•‘
â•‘  Endianness:            Little-endian                                   â•‘
â•‘  Register r0:           Hardwired to zero (writes ignored)              â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ—‚ï¸ TYPE ALLOCATION MAP
gcode
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ TYPE FIELD [127:122] - 64 Instruction Types                             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ 0x00-0x07: CONTROL FLOW                                                 â•‘
â•‘   0x00  NOP        No operation                                         â•‘
â•‘   0x01  BR         Branch conditional                                   â•‘
â•‘   0x02  JMP        Unconditional jump (absolute)                        â•‘
â•‘   0x03  CALL       Call subroutine                                      â•‘
â•‘   0x04  RET        Return from subroutine                               â•‘
â•‘   0x05  CALLR      Call register-indirect                               â•‘
â•‘   0x06  JMPR       Jump register-indirect                               â•‘
â•‘   0x07  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x08-0x0F: SCALAR ALU                                                   â•‘
â•‘   0x08  ALU2       Dual-source ALU (Rd = Rs1 OP Rs2)                    â•‘
â•‘   0x09  ALU1       Single-source ALU (Rd = OP Rs1)                      â•‘
â•‘   0x0A  ALUI       ALU with immediate (Rd = Rs1 OP imm)                 â•‘
â•‘   0x0B  CMP        Compare (flags only, no writeback)                   â•‘
â•‘   0x0C  CMOV       Conditional move                                     â•‘
â•‘   0x0D  SEL        Select (Rd = cond ? Rs1 : Rs2)                       â•‘
â•‘   0x0E  RESERVED                                                        â•‘
â•‘   0x0F  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x10-0x17: PARALLEL ALU                                                 â•‘
â•‘   0x10  DUAL       2Ã— independent ALU ops (different ops)               â•‘
â•‘   0x11  QUAD       4Ã— independent ALU ops (same op)                     â•‘
â•‘   0x12  TRIPLE     3Ã— independent ALU ops                               â•‘
â•‘   0x13  RESERVED                                                        â•‘
â•‘   0x14  RESERVED                                                        â•‘
â•‘   0x15  RESERVED                                                        â•‘
â•‘   0x16  RESERVED                                                        â•‘
â•‘   0x17  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x18-0x1F: DATA MOVEMENT                                                â•‘
â•‘   0x18  MOVI       Move immediate (Rd = imm64)                          â•‘
â•‘   0x19  MOV        Move register (Rd = Rs)                              â•‘
â•‘   0x1A  SWAP       Swap two registers                                   â•‘
â•‘   0x1B  MVPAIR     Move register pair                                   â•‘
â•‘   0x1C  MVQUAD     Move 4 registers (parallel)                          â•‘
â•‘   0x1D  BCAST      Broadcast (imm â†’ multiple registers)                 â•‘
â•‘   0x1E  RESERVED                                                        â•‘
â•‘   0x1F  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x20-0x27: MEMORY LOAD                                                  â•‘
â•‘   0x20  LD         Load (Rd = Mem[Rs + imm])                            â•‘
â•‘   0x21  LDX        Load indexed (Rd = Mem[Rs1 + Rs2Ã—scale + imm])       â•‘
â•‘   0x22  LDA        Load absolute (Rd = Mem[imm64])                      â•‘
â•‘   0x23  LDPAIR     Load pair (consecutive addresses)                    â•‘
â•‘   0x24  LDQUAD     Load quad (4 consecutive values)                     â•‘
â•‘   0x25  PREFETCH   Prefetch to cache                                    â•‘
â•‘   0x26  RESERVED                                                        â•‘
â•‘   0x27  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x28-0x2F: MEMORY STORE                                                 â•‘
â•‘   0x28  ST         Store (Mem[Rs1 + imm] = Rs2)                         â•‘
â•‘   0x29  STX        Store indexed (Mem[Rs1 + Rs2Ã—scale + imm] = Rs3)     â•‘
â•‘   0x2A  STA        Store absolute (Mem[imm64] = Rs)                     â•‘
â•‘   0x2B  STPAIR     Store pair                                           â•‘
â•‘   0x2C  STQUAD     Store quad                                           â•‘
â•‘   0x2D  FLUSH      Flush cache line                                     â•‘
â•‘   0x2E  RESERVED                                                        â•‘
â•‘   0x2F  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x30-0x37: ATOMIC OPERATIONS                                            â•‘
â•‘   0x30  AMO        Atomic memory operation (ADD/AND/OR/XOR/SWAP)        â•‘
â•‘   0x31  CAS        Compare-and-swap                                     â•‘
â•‘   0x32  CAS2       Double-width CAS (128-bit)                           â•‘
â•‘   0x33  LL         Load-linked                                          â•‘
â•‘   0x34  SC         Store-conditional                                    â•‘
â•‘   0x35  AMOMAX     Atomic max/min operations                            â•‘
â•‘   0x36  RESERVED                                                        â•‘
â•‘   0x37  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x38-0x3F: SIMD/VECTOR                                                  â•‘
â•‘   0x38  VALU       Vector ALU (element-wise)                            â•‘
â•‘   0x39  VFMA       Vector fused multiply-add                            â•‘
â•‘   0x3A  VRED       Vector reduction (horizontal)                        â•‘
â•‘   0x3B  VSHUFFLE   Vector shuffle/permute                               â•‘
â•‘   0x3C  VEXTRACT   Extract vector element                               â•‘
â•‘   0x3D  VINSERT    Insert vector element                                â•‘
â•‘   0x3E  VBCAST     Broadcast scalar to vector                           â•‘
â•‘   0x3F  VCMP       Vector compare (generate mask)                       â•‘
â•‘                                                                          â•‘
â•‘ 0x40-0x47: SYSTEM/CONTROL                                               â•‘
â•‘   0x40  FENCE      Memory fence                                         â•‘
â•‘   0x41  CSRRW      CSR read-write                                       â•‘
â•‘   0x42  CSRR       CSR read-only                                        â•‘
â•‘   0x43  CSRW       CSR write-only                                       â•‘
â•‘   0x44  SYSCALL    System call                                          â•‘
â•‘   0x45  BREAK      Breakpoint                                           â•‘
â•‘   0x46  HALT       Halt processor                                       â•‘
â•‘   0x47  ERET       Exception return                                     â•‘
â•‘                                                                          â•‘
â•‘ 0x48-0x4F: BIT MANIPULATION                                             â•‘
â•‘   0x48  BITOPS     Bit operations (POPCNT/CLZ/CTZ/BSWAP)                â•‘
â•‘   0x49  BITFIELD   Bit field extract/insert                             â•‘
â•‘   0x4A  PDEP       Parallel bit deposit                                 â•‘
â•‘   0x4B  PEXT       Parallel bit extract                                 â•‘
â•‘   0x4C  CRC        CRC calculation                                      â•‘
â•‘   0x4D  RESERVED                                                        â•‘
â•‘   0x4E  RESERVED                                                        â•‘
â•‘   0x4F  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x50-0x57: FLOATING POINT                                               â•‘
â•‘   0x50  FP2        Dual FP operations                                   â•‘
â•‘   0x51  FPALU      Single FP operation                                  â•‘
â•‘   0x52  FPFMA      FP fused multiply-add                                â•‘
â•‘   0x53  FPCMP      FP compare                                           â•‘
â•‘   0x54  FPCONV     FP conversion                                        â•‘
â•‘   0x55  FPSQRT     FP square root                                       â•‘
â•‘   0x56  FPDIV      FP division                                          â•‘
â•‘   0x57  FPCLASS    FP classify (NaN/Inf/Zero)                           â•‘
â•‘                                                                          â•‘
â•‘ 0x58-0x5F: SPECIAL PURPOSE                                              â•‘
â•‘   0x58  CRYPTO     Cryptographic operations (AES/SHA)                   â•‘
â•‘   0x59  COMPRESS   Compression primitives                               â•‘
â•‘   0x5A  NEURAL     Neural network ops (dot product/conv)                â•‘
â•‘   0x5B  MATRIX     Matrix operations (GEMM)                             â•‘
â•‘   0x5C  RESERVED                                                        â•‘
â•‘   0x5D  RESERVED                                                        â•‘
â•‘   0x5E  RESERVED                                                        â•‘
â•‘   0x5F  RESERVED                                                        â•‘
â•‘                                                                          â•‘
â•‘ 0x60-0x3F: FUTURE EXPANSION (Reserved)                                  â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ INSTRUCTION FORMAT TEMPLATES
Format R: Register-Register Operations
json
  127      122 121      116 115                                         96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚ Operation â”‚            Reserved                         â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚            [20b]                            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79        72 71        70 69                 0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs1      â”‚  Rs2      â”‚  Rd       â”‚ FlagUpdate â”‚   Reserved         â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [8b]     â”‚   [2b]     â”‚   [70b]            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  FlagUpdate [71:70]:
    00: No flag update (preserve existing flags)
    01: Update flags from result
    10: Reserved
    11: Reserved

Total: 6 + 6 + 20 + 8 + 8 + 8 + 2 + 70 = 128 bits âœ…

Used by: ALU2, ALU1, CMP, CMOV, SEL, MOV, SWAP

Format I: Immediate Operations
json
  127      122 121      116 115                                         96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚ Operation â”‚            Reserved                         â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚            [20b]                            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79                                         16
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs       â”‚  Rd       â”‚  Immediate (64 bits)                         â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [64b]                                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  15        14 13                                                        0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ FlagUpdate â”‚            Reserved                                     â”‚
  â”‚   [2b]     â”‚            [14b]                                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total: 6 + 6 + 20 + 8 + 8 + 64 + 2 + 14 = 128 bits âœ…

Used by: ALUI, MOVI, BCAST

Format M: Memory Operations
json
  127      122 121                113 112  110 109  108                  96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚      Reserved       â”‚  Size  â”‚ Sign  â”‚   Ordering         â”‚
  â”‚   [6b]    â”‚      [9b]           â”‚  [3b]  â”‚ [1b]  â”‚   [3b]             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79                                         16
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs_addr  â”‚  Rd_data  â”‚  Offset (64 bits, signed)                    â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [64b]                                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  15                                                                      0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                     â”‚
  â”‚                        [16b]                                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Size [112:110]:
    000: 8-bit (byte)
    001: 16-bit (halfword)
    010: 32-bit (word)
    011: 64-bit (doubleword)
    100-111: Reserved (future 128/256/512-bit)
    
  Sign [109]:
    0: Zero-extend (unsigned)
    1: Sign-extend (signed)
    
  Ordering [108:106]:
    000: Normal (relaxed)
    001: Acquire (load-acquire)
    010: Release (store-release)
    011: AcqRel (both)
    100: SeqCst (sequentially consistent)
    101-111: Reserved

Total: 6 + 9 + 3 + 1 + 3 + 8 + 8 + 64 + 16 = 128 bits âœ…

Used by: LD, ST, LDA, STA

Note: For LD, Rs_addr is base, Rd_data is destination. For ST, Rs_addr is data source, Rd_data is base address. Fields swap interpretation to maintain left-to-right assembly syntax.

Format X: Indexed Memory Operations
json
  127      122 121                113 112  110 109  108            103 102 96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚      Reserved       â”‚  Size  â”‚ Sign  â”‚  Reserved    â”‚ Scale â”‚
  â”‚   [6b]    â”‚      [9b]           â”‚  [3b]  â”‚ [1b]  â”‚  [6b]        â”‚ [3b]  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79        72 71                                16
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs_base  â”‚  Rs_index â”‚  Rd_data  â”‚  Offset (56 bits, signed)            â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [8b]     â”‚  [56b]                               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  15                                                                         0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                          â”‚
  â”‚                        [16b]                                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Scale [102:96]:
    000: Ã—1 (byte)
    001: Ã—2 (halfword)
    010: Ã—4 (word)
    011: Ã—8 (doubleword)
    100: Ã—16
    101-111: Reserved

Total: 6 + 9 + 3 + 1 + 6 + 3 + 8 + 8 + 8 + 56 + 16 = 128 bits âœ…

Used by: LDX, STX

Address calculation: EA = Rs_base + (Rs_index << scale) + sign_extend(offset)

Format D: Dual Parallel ALU
json
  127      122 121      116 115      110 109                     98 97  96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚   Op A    â”‚   Op B    â”‚      Reserved            â”‚FlagSel â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚   [6b]    â”‚      [12b]               â”‚ [2b]   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95     88 87     80 79     72 71     64 63     56 55     48 47         0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ A:Rs1   â”‚ A:Rs2   â”‚ A:Rd    â”‚ B:Rs1   â”‚ B:Rs2   â”‚ B:Rd    â”‚ Reserved â”‚
  â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [48b]   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  FlagSel [97:96]:
    00: No flags updated
    01: Operation A updates flags
    10: Operation B updates flags
    11: Both update flags (B's flags win, last write)

Total: 6 + 6 + 6 + 12 + 2 + 48 + 48 = 128 bits âœ…

Used by: DUAL

Format Q: Quad Parallel ALU
clojure
  127      122 121      116 115                               98 97    96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚ Operation â”‚         Reserved                 â”‚ FlagSel  â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚         [18b]                    â”‚  [2b]    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95     88 87     80 79     72 71     64 63     56 55     48 47     40 39  32
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
  â”‚ 0:Rs1   â”‚ 0:Rs2   â”‚ 0:Rd    â”‚ 1:Rs1   â”‚ 1:Rs2   â”‚ 1:Rd    â”‚ 2:Rs1   â”‚2:Rs2â”‚
  â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚ [8b]â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  31     24 23     16 15      8 7                                         0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 2:Rd    â”‚ 3:Rs1   â”‚ 3:Rs2   â”‚ 3:Rd + Reserved                          â”‚
  â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b] + [0b]                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  FlagSel [97:96]:
    00: No flags updated
    01: Operation 0 updates flags
    10: Operation 1 updates flags
    11: Operation 2 updates flags

Total: 6 + 6 + 18 + 2 + 96 = 128 bits âœ…

Used by: QUAD

Format T: Triple Parallel ALU
json
  127      122 121      116 115      110 109      104 103            98 97 96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚   Op A    â”‚   Op B    â”‚   Op C    â”‚    Reserved      â”‚FlagSeâ”‚
  â”‚   [6b]    â”‚   [6b]    â”‚   [6b]    â”‚   [6b]    â”‚    [6b]          â”‚ [2b] â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
  95     88 87     80 79     72 71     64 63     56 55     48 47     40 39  32
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
  â”‚ A:Rs1   â”‚ A:Rs2   â”‚ A:Rd    â”‚ B:Rs1   â”‚ B:Rs2   â”‚ B:Rd    â”‚ C:Rs1   â”‚C:Rs2â”‚
  â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚  [8b]   â”‚ [8b]â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  31     24 23                                                            0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ C:Rd    â”‚                    Reserved                                  â”‚
  â”‚  [8b]   â”‚                    [24b]                                     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  FlagSel [97:96]:
    00: No flags updated
    01: Operation A updates flags
    10: Operation B updates flags
    11: Operation C updates flags

Total: 6 + 6 + 6 + 6 + 6 + 2 + 72 + 24 = 128 bits âœ…

Used by: TRIPLE

Format B: Branch Operations
json
  127      122 121      118 117                                         96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚ Condition â”‚            Reserved                         â”‚
  â”‚   [6b]    â”‚   [4b]    â”‚            [22b]                            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95                                                                    32
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                  Target Address (64 bits)                          â”‚
  â”‚                  [64b]                                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  31                                                                     0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                    â”‚
  â”‚                        [32b]                                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Condition [121:118]:
    0x0: ALWAYS (unconditional)
    0x1: EQ  (ZF=1)
    0x2: NE  (ZF=0)
    0x3: LT  (SFâ‰ OF, signed less)
    0x4: LE  (ZF=1 || SFâ‰ OF)
    0x5: GT  (ZF=0 && SF=OF)
    0x6: GE  (SF=OF)
    0x7: LTU (CF=1, unsigned less)
    0x8: LEU (CF=1 || ZF=1)
    0x9: GTU (CF=0 && ZF=0)
    0xA: GEU (CF=0)
    0xB: OF  (OF=1)
    0xC: NOF (OF=0)
    0xD: SF  (SF=1, negative)
    0xE: NSF (SF=0, positive/zero)
    0xF: NEVER (always fall through)

Total: 6 + 4 + 22 + 64 + 32 = 128 bits âœ…

Used by: BR, JMP (JMP uses condition=ALWAYS)

Format C: Call/Return Operations
json
  127      122 121                                                      96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚                   Reserved                              â”‚
  â”‚   [6b]    â”‚                   [26b]                                 â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87                                                      32
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rd_link  â”‚  Target Address (56 bits)                                â”‚
  â”‚  [8b]     â”‚  [56b]                                                   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  31                                                                     0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                    â”‚
  â”‚                        [32b]                                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total: 6 + 26 + 8 + 56 + 32 = 128 bits âœ…

Used by: CALL, CALLR, RET

For RET: Target address field ignored, Rd_link contains return address register

Format V: Vector/SIMD Operations
json
  127      122 121      116 115  113 112                               96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚ Operation â”‚ElemWidthâ”‚         Reserved                    â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚  [3b]  â”‚         [17b]                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79        72 71                               0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs1      â”‚  Rs2      â”‚  Rd       â”‚         Reserved                   â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [8b]     â”‚         [72b]                      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ElemWidth [115:113]:
    000: Reserved
    001: 8-bit elements (8Ã— ops per 64-bit register)
    010: 16-bit elements (4Ã— ops)
    011: 32-bit elements (2Ã— ops)
    100: 64-bit elements (1Ã— op, scalar)
    101-111: Reserved (future 128/256/512-bit)

Total: 6 + 6 + 3 + 17 + 8 + 8 + 8 + 72 = 128 bits âœ…

Used by: VALU, VFMA, VCMP

Format A: Atomic Operations
json
  127      122 121      116 115  113 112  110 109                       96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚   AMO Op  â”‚  Size  â”‚ Order  â”‚         Reserved             â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚  [3b]  â”‚  [3b]  â”‚         [14b]                â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79                                         16
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs_new   â”‚  Rd_old   â”‚  Address (64 bits)                           â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [64b]                                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  15                                                                      0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                     â”‚
  â”‚                        [16b]                                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  AMO Op [121:116]:
    0x00: SWAP    Atomic exchange
    0x01: ADD     Fetch-and-add
    0x02: SUB     Fetch-and-sub
    0x03: AND     Fetch-and-AND
    0x04: OR      Fetch-and-OR
    0x05: XOR     Fetch-and-XOR
    0x06: MIN     Fetch-and-min (signed)
    0x07: MAX     Fetch-and-max (signed)
    0x08: MINU    Fetch-and-min (unsigned)
    0x09: MAXU    Fetch-and-max (unsigned)
    0x0A-0x3F: Reserved
    
  Order [112:110]:
    000: RELAXED
    001: ACQUIRE
    010: RELEASE
    011: ACQ_REL
    100: SEQ_CST
    101-111: Reserved

Total: 6 + 6 + 3 + 3 + 14 + 8 + 8 + 64 + 16 = 128 bits âœ…

Used by: AMO, AMOMAX

Format CAS: Compare-And-Swap
json
  127      122 121                113 112  110 109                       96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚      Reserved       â”‚  Size  â”‚         Reserved             â”‚
  â”‚   [6b]    â”‚      [9b]           â”‚  [3b]  â”‚         [14b]                â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79        72 71                              16
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs_new   â”‚  Rs_cmp   â”‚  Rd_old   â”‚  Address (56 bits)                 â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [8b]     â”‚  [56b]                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  15                                                                       0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                      â”‚
  â”‚                        [16b]                                         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total: 6 + 9 + 3 + 14 + 8 + 8 + 8 + 56 + 16 = 128 bits âœ…

Used by: CAS, CAS2

Format S: System/CSR Operations
json
  127      122 121      116 115                                         96
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Type    â”‚  Sub-op   â”‚            Reserved                         â”‚
  â”‚   [6b]    â”‚   [6b]    â”‚            [20b]                            â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  95        88 87        80 79                                         16
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Rs       â”‚  Rd       â”‚  CSR Address / Immediate (64 bits)           â”‚
  â”‚  [8b]     â”‚  [8b]     â”‚  [64b]                                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  15                                                                      0
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        Reserved                                     â”‚
  â”‚                        [16b]                                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total: 6 + 6 + 20 + 8 + 8 + 64 + 16 = 128 bits âœ…

Used by: CSRRW, CSRR, CSRW, SYSCALL, FENCE

ğŸ”§ OPERATION ENCODINGS
ALU Operations (6 bits, used in Operation field)
ini
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ OPERATION FIELD [121:116] - ALU Operations                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ 0x00-0x0F: ARITHMETIC                                                   â•‘
â•‘   0x00  ADD        Rd = Rs1 + Rs2                                       â•‘
â•‘   0x01  SUB        Rd = Rs1 - Rs2                                       â•‘
â•‘   0x02  RSUB       Rd = Rs2 - Rs1 (reverse subtract)                    â•‘
â•‘   0x03  MUL        Rd = (Rs1 Ã— Rs2)[63:0]                               â•‘
â•‘   0x04  MULH       Rd = (Rs1 Ã— Rs2)[127:64] (signed)                    â•‘
â•‘   0x05  MULHU      Rd = (Rs1 Ã— Rs2)[127:64] (unsigned)                  â•‘
â•‘   0x06  MULHSU     Rd = (signed Rs1 Ã— unsigned Rs2)[127:64]             â•‘
â•‘   0x07  DIV        Rd = Rs1 / Rs2 (signed)                              â•‘
â•‘   0x08  DIVU       Rd = Rs1 / Rs2 (unsigned)                            â•‘
â•‘   0x09  REM        Rd = Rs1 % Rs2 (signed remainder)                    â•‘
â•‘   0x0A  REMU       Rd = Rs1 % Rs2 (unsigned remainder)                  â•‘
â•‘   0x0B  NEG        Rd = -Rs1 (two's complement)                         â•‘
â•‘   0x0C  ABS        Rd = |Rs1| (absolute value)                          â•‘
â•‘   0x0D  INC        Rd = Rs1 + 1                                         â•‘
â•‘   0x0E  DEC        Rd = Rs1 - 1                                         â•‘
â•‘   0x0F  ADDC       Rd = Rs1 + Rs2 + CF (add with carry)                 â•‘
â•‘                                                                          â•‘
â•‘ 0x10-0x1F: LOGICAL                                                      â•‘
â•‘   0x10  AND        Rd = Rs1 & Rs2                                       â•‘
â•‘   0x11  OR         Rd = Rs1 | Rs2                                       â•‘
â•‘   0x12  XOR        Rd = Rs1 ^ Rs2                                       â•‘
â•‘   0x13  NOT        Rd = ~Rs1                                            â•‘
â•‘   0x14  NAND       Rd = ~(Rs1 & Rs2)                                    â•‘
â•‘   0x15  NOR        Rd = ~(Rs1 | Rs2)                                    â•‘
â•‘   0x16  XNOR       Rd = ~(Rs1 ^ Rs2)                                    â•‘
â•‘   0x17  ANDN       Rd = Rs1 & ~Rs2 (and-not)                            â•‘
â•‘   0x18  ORN        Rd = Rs1 | ~Rs2 (or-not)                             â•‘
â•‘   0x19  TEST       Rd = (Rs1 & Rs2) ? 1 : 0                             â•‘
â•‘   0x1A-0x1F: Reserved                                                   â•‘
â•‘                                                                          â•‘
â•‘ 0x20-0x2F: SHIFTS                                                       â•‘
â•‘   0x20  SLL        Rd = Rs1 << Rs2 (shift left logical)                 â•‘
â•‘   0x21  SRL        Rd = Rs1 >> Rs2 (shift right logical)                â•‘
â•‘   0x22  SRA        Rd = Rs1 >> Rs2 (shift right arithmetic)             â•‘
â•‘   0x23  ROL        Rd = rotate_left(Rs1, Rs2)                           â•‘
â•‘   0x24  ROR        Rd = rotate_right(Rs1, Rs2)                          â•‘
â•‘   0x25  FUNNEL     Rd = funnel_shift(Rs1, Rs2, shift_amt)               â•‘
â•‘   0x26-0x2F: Reserved                                                   â•‘
â•‘                                                                          â•‘
â•‘ 0x30-0x3F: COMPARE & SELECT                                             â•‘
â•‘   0x30  SEQ        Rd = (Rs1 == Rs2) ? 1 : 0                            â•‘
â•‘   0x31  SNE        Rd = (Rs1 != Rs2) ? 1 : 0                            â•‘
â•‘   0x32  SLT        Rd = (Rs1 < Rs2) ? 1 : 0 (signed)                    â•‘
â•‘   0x33  SLE        Rd = (Rs1 <= Rs2) ? 1 : 0 (signed)                   â•‘
â•‘   0x34  SGT        Rd = (Rs1 > Rs2) ? 1 : 0 (signed)                    â•‘
â•‘   0x35  SGE        Rd = (Rs1 >= Rs2) ? 1 : 0 (signed)                   â•‘
â•‘   0x36  SLTU       Rd = (Rs1 < Rs2) ? 1 : 0 (unsigned)                  â•‘
â•‘   0x37  SLEU       Rd = (Rs1 <= Rs2) ? 1 : 0 (unsigned)                 â•‘
â•‘   0x38  SGTU       Rd = (Rs1 > Rs2) ? 1 : 0 (unsigned)                  â•‘
â•‘   0x39  SGEU       Rd = (Rs1 >= Rs2) ? 1 : 0 (unsigned)                 â•‘
â•‘   0x3A  MIN        Rd = min(Rs1, Rs2) (signed)                          â•‘
â•‘   0x3B  MAX        Rd = max(Rs1, Rs2) (signed)                          â•‘
â•‘   0x3C  MINU       Rd = min(Rs1, Rs2) (unsigned)                        â•‘
â•‘   0x3D  MAXU       Rd = max(Rs1, Rs2) (unsigned)                        â•‘
â•‘   0x3E-0x3F: Reserved                                                   â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“– COMPLETE INSTRUCTION SPECIFICATIONS
GROUP 0x00-0x07: CONTROL FLOW
0x00: NOP - No Operation
Format: All zeros

basic
Encoding: 0x00000000_00000000_00000000_00000000

Execution: PC = PC + 16 (advance to next instruction)
Latency: 0 cycles (removed during decode)
Î¼Ops: 0 (eliminated in front-end)

Assembly:

asm
NOP

Use cases:

Instruction alignment padding
Pipeline bubbles
Code patching placeholders
Cache line alignment
0x01: BR - Branch Conditional
Format: B

Encoding:

Type: 0x01
Condition [121:118]: 4-bit condition code
Target [95:32]: 64-bit absolute address

Assembly:

asm
BR.cond target_address

Examples:
BR.EQ 0x0000000000401000      ; if (ZF==1) PC = 0x401000
BR.LT 0x0000000000402000      ; if (SFâ‰ OF) PC = 0x402000
BR.GTU 0x0000000000403000     ; if (CF==0 && ZF==0) PC = 0x403000
BR.ALWAYS 0x0000000000404000  ; Unconditional (same as JMP)

Condition Codes:

apache
EQ    (0x1): ZF == 1
NE    (0x2): ZF == 0
LT    (0x3): SF â‰  OF
LE    (0x4): ZF == 1 || SF â‰  OF
GT    (0x5): ZF == 0 && SF == OF
GE    (0x6): SF == OF
LTU   (0x7): CF == 1
LEU   (0x8): CF == 1 || ZF == 1
GTU   (0x9): CF == 0 && ZF == 0
GEU   (0xA): CF == 0
OF    (0xB): OF == 1
NOF   (0xC): OF == 0
SF    (0xD): SF == 1
NSF   (0xE): SF == 0
ALWAYS(0x0): Always taken
NEVER (0xF): Never taken (NOP)

Execution:

c
if (condition_met(flags, condition_code)) {
  PC = target_address;
} else {
  PC = PC + 16;
}

Latency: 1 cycle (predicted), 15-20 cycles (mispredicted)

Î¼Ops: 1 (conditional branch micro-op)

0x02: JMP - Unconditional Jump
Format: B (condition = ALWAYS)

Assembly:

asm
JMP 0x0000000000401000
  ; PC = 0x401000
  ; Unconditional jump to absolute address

Execution:

c
PC = target_address;

Latency: 1 cycle (always predicted correctly via BTB)

Î¼Ops: 1

Note: Functionally equivalent to BR.ALWAYS, but may have different branch prediction treatment.

0x03: CALL - Call Subroutine
Format: C

Encoding:

Type: 0x03
Rd_link [95:88]: Link register (stores return address)
Target [87:32]: 56-bit target address (zero-extended to 64-bit)

Assembly:

asm
CALL 0x0000000000402000 â†’ r1
  ; r1 = PC + 16 (return address)
  ; PC = 0x402000
  ; Left-to-right: Function call returns TO r1

Execution:

c
Rd_link = PC + 16;
PC = zero_extend(target[55:0]);

Latency: 1 cycle (predicted via RAS - Return Address Stack)

Î¼Ops: 2

Move PC+16 to link register
Jump to target
Note: 56-bit target allows addressing up to 64 PB (petabytes) of code space.

0x04: RET - Return from Subroutine
Format: C (target field ignored)

Encoding:

Type: 0x04
Rd_link [95:88]: Link register containing return address
Target: Ignored (reserved, should be zero)

Assembly:

asm
RET r1
  ; PC = r1
  ; Return via link register

Execution:

c
PC = Rd_link;

Latency: 1 cycle (predicted via RAS)

Î¼Ops: 1 (indirect jump)

Branch Prediction: Uses Return Address Stack (RAS) for prediction. Typical RAS depth: 32-64 entries.

0x05: CALLR - Call Register-Indirect
Format: C

Encoding:

Type: 0x05
Rd_link [95:88]: Link register
Rs_target [87:80]: Register containing target address

Assembly:

asm
CALLR r5 â†’ r1
  ; r1 = PC + 16
  ; PC = r5
  ; Indirect call (target in register)

Execution:

c
Rd_link = PC + 16;
PC = Rs_target;

Use cases:

Function pointers
Virtual function calls
Dynamic dispatch
PLT (Procedure Linkage Table) trampolines
Latency: 2 cycles (indirect target requires register read)

Î¼Ops: 2

0x06: JMPR - Jump Register-Indirect
Format: C (link register ignored)

Encoding:

Type: 0x06
Rs_target [95:88]: Register containing target address

Assembly:

asm
JMPR r5
  ; PC = r5
  ; Indirect jump (no link register update)

Use cases:

Computed jumps
Switch table dispatch
Tail call optimization
Latency: 2 cycles

Î¼Ops: 1

GROUP 0x08-0x0F: SCALAR ALU
0x08: ALU2 - Dual-Source ALU
Format: R

Encoding:

json
Type: 0x08
Operation [121:116]: 6-bit ALU operation (see table above)
Rs1 [95:88]: First source register
Rs2 [87:80]: Second source register
Rd [79:72]: Destination register
FlagUpdate [71:70]: 01 = update flags, 00 = preserve flags

Assembly:

asm
ALU2.op Rs1, Rs2 â†’ Rd, flags=FLAG

Examples:
ALU2.ADD r5, r6 â†’ r10, flags=1
  ; r10 = r5 + r6
  ; Flags updated (ZF, SF, CF, OF)

ALU2.SUB r20, r21 â†’ r22, flags=0
  ; r22 = r20 - r21
  ; Flags preserved (no update)

ALU2.MUL r1, r2 â†’ r3, flags=1
  ; r3 = (r1 Ã— r2)[63:0]
  ; Lower 64 bits of multiply

ALU2.AND r50, r51 â†’ r52, flags=0
  ; r52 = r50 & r51
  ; Flags unchanged

ALU2.SLL r10, r11 â†’ r12, flags=1
  ; r12 = r10 << r11
  ; Shift left logical

Supported Operations: All 0x00-0x3F from ALU operations table

Latency by operation:

basic
ADD/SUB/LOGICAL/SHIFTS: 1 cycle
MUL/MULH:               3 cycles
DIV/REM:                18 cycles (not pipelined)

Î¼Ops: 1

Flags Updated (when FlagUpdate=01):

ZF (Zero):      Result == 0
SF (Sign):      Result[63] (MSB)
CF (Carry):     Carry-out from bit 63 (ADD/SUB)
OF (Overflow):  Signed overflow occurred
PF (Parity):    Parity of result[7:0]

0x09: ALU1 - Single-Source ALU
Format: R (Rs2 ignored)

Encoding:

json
Type: 0x09
Operation [121:116]: Unary operations only
Rs1 [95:88]: Source register
Rs2 [87:80]: Ignored (set to r0)
Rd [79:72]: Destination register
FlagUpdate [71:70]: 01 = update, 00 = preserve

Assembly:

asm
ALU1.op Rs1 â†’ Rd, flags=FLAG

Examples:
ALU1.NOT r5 â†’ r10, flags=0
  ; r10 = ~r5
  ; Bitwise NOT

ALU1.NEG r20 â†’ r21, flags=1
  ; r21 = -r20
  ; Two's complement negation

ALU1.ABS r30 â†’ r31, flags=1
  ; r31 = |r30|
  ; Absolute value (signed)

ALU1.INC r1 â†’ r1, flags=1
  ; r1 = r1 + 1
  ; Increment (self-modifying)

Unary Operations:

ini
0x0B: NEG   Rd = -Rs1
0x0C: ABS   Rd = |Rs1|
0x0D: INC   Rd = Rs1 + 1
0x0E: DEC   Rd = Rs1 - 1
0x13: NOT   Rd = ~Rs1

Latency: 1 cycle

Î¼Ops: 1

0x0A: ALUI - ALU with Immediate
Format: I

Encoding:

json
Type: 0x0A
Operation [121:116]: 6-bit ALU operation
Rs [95:88]: Source register
Rd [87:80]: Destination register
Immediate [79:16]: 64-bit signed immediate
FlagUpdate [15:14]: 01 = update, 00 = preserve

Assembly:

asm
ALUI.op Rs, imm64 â†’ Rd, flags=FLAG

Examples:
ALUI.ADD r5, 0x1000 â†’ r10, flags=1
  ; r10 = r5 + 4096
  ; Add immediate

ALUI.SUB r20, -100 â†’ r21, flags=0
  ; r21 = r20 - (-100) = r20 + 100
  ; Subtract negative = add

ALUI.AND r1, 0xFF â†’ r2, flags=0
  ; r2 = r1 & 0xFF
  ; Mask lower byte

ALUI.SLL r10, 3 â†’ r10, flags=1
  ; r10 = r10 << 3
  ; Multiply by 8

ALUI.OR r5, 0x8000000000000000 â†’ r6, flags=0
  ; r6 = r5 | 0x8000000000000000
  ; Set MSB

Immediate Range: Full 64-bit signed (-2^63 to 2^63-1)

Latency: Same as ALU2 (1 cycle for most ops)

Î¼Ops: 1

0x0B: CMP - Compare (Flags Only)
Format: R (Rd ignored)

Encoding:

json
Type: 0x0B
Operation [121:116]: Comparison operation (SUB typically)
Rs1 [95:88]: First operand
Rs2 [87:80]: Second operand
Rd [79:72]: Ignored (no writeback)
FlagUpdate [71:70]: Forced to 01 (always updates flags)

Assembly:

asm
CMP.op Rs1, Rs2

Examples:
CMP.SUB r10, r11
  ; temp = r10 - r11
  ; Flags updated based on temp
  ; temp discarded (no register write)
  ; Use before conditional branch

CMP.AND r5, r6
  ; temp = r5 & r6
  ; Test if any bits match
  ; ZF = 1 if no bits match

Execution:

c
temp = Rs1 OP Rs2;
flags = update_flags(temp);
// No writeback to register file

Purpose: Set flags for subsequent conditional branch without wasting a register.

Latency: 1 cycle

Î¼Ops: 1 (no writeback, so simpler)

Typical usage pattern:

asm
CMP.SUB r10, r11      ; Compare r10 vs r11
BR.EQ equal_label     ; Branch if equal
BR.LT less_label      ; Branch if r10 < r11

0x0C: CMOV - Conditional Move
Format: R

Encoding:

json
Type: 0x0C
Operation [121:116]: Condition code (0x00-0x0F, same as BR)
Rs1 [95:88]: Source register (value to move if condition true)
Rs2 [87:80]: Ignored
Rd [79:72]: Destination register
FlagUpdate [71:70]: Always 00 (never updates flags)

Assembly:

asm
CMOV.cond Rs1 â†’ Rd

Examples:
CMOV.EQ r5 â†’ r10
  ; if (ZF == 1) r10 = r5
  ; else r10 unchanged

CMOV.LT r20 â†’ r21
  ; if (SF â‰  OF) r21 = r20
  ; Conditional assignment without branching

CMOV.GTU r30 â†’ r31
  ; if (CF == 0 && ZF == 0) r31 = r30

Execution:

c
if (condition_met(flags, condition_code)) {
  Rd = Rs1;
}
// Rd unchanged otherwise

Use case: Branchless conditional assignment (avoids branch misprediction penalty)

Latency: 1 cycle (predicated execution)

Î¼Ops: 1 (predicated move)

Example code pattern:

asm
CMP.SUB r10, r11       ; Compare
CMOV.LT r20 â†’ r10      ; r10 = (r10 < r11) ? r20 : r10
; Equivalent to: if (r10 < r11) r10 = r20;

0x0D: SEL - Select
Format: R

Encoding:

json
Type: 0x0D
Operation [121:116]: Condition code
Rs1 [95:88]: Value if condition true
Rs2 [87:80]: Value if condition false
Rd [79:72]: Destination
FlagUpdate [71:70]: Always 00

Assembly:

asm
SEL.cond Rs1, Rs2 â†’ Rd

Examples:
SEL.EQ r5, r6 â†’ r10
  ; r10 = (ZF == 1) ? r5 : r6
  ; Ternary operator: r10 = cond ? r5 : r6

SEL.LT r20, r21 â†’ r22
  ; r22 = (SF â‰  OF) ? r20 : r21

Execution:

c
Rd = condition_met(flags, condition_code) ? Rs1 : Rs2;

Use case: Branchless ternary selection

Latency: 1 cycle

Î¼Ops: 1

GROUP 0x10-0x17: PARALLEL ALU
0x10: DUAL - Dual Parallel ALU
Format: D

Encoding:

json
Type: 0x10
Op A [121:116]: Operation for first ALU
Op B [115:110]: Operation for second ALU
FlagSel [97:96]: 00=none, 01=A, 10=B, 11=both (B wins)

Operation A:
  Rs1 [95:88], Rs2 [87:80] â†’ Rd [79:72]
  
Operation B:
  Rs1 [71:64], Rs2 [63:56] â†’ Rd [55:48]

Assembly:

asm
DUAL [opA Rs1, Rs2 â†’ Rd] [opB Rs1, Rs2 â†’ Rd], flags=SEL

Examples:
DUAL [ADD r5, r6 â†’ r10] [SUB r20, r21 â†’ r22], flags=A
  ; r10 = r5 + r6  (executes, updates flags)
  ; r22 = r20 - r21  (executes, no flag update)
  ; Both operations complete in same cycle

DUAL [MUL r1, r2 â†’ r3] [AND r4, r5 â†’ r6], flags=B
  ; r3 = r1 Ã— r2  (executes, no flag update)
  ; r6 = r4 & r5  (executes, updates flags)

DUAL [SLL r10, r11 â†’ r12] [SRL r13, r14 â†’ r15], flags=0
  ; Both execute, neither updates flags
  ; Useful when flags already set by prior CMP

Execution: Both operations dispatch to separate ALU units in parallel

Constraints:

Operations must be independent (no RAW hazard between A and B)
If Rd_A == Rd_B, behavior undefined (hardware may serialize)
Both operations use same cycle's flag state as input
Latency: Max(latency_A, latency_B)

Both ADD/SUB: 1 cycle
One MUL: 3 cycles total
One DIV: 18 cycles total (serializes in practice)

Î¼Ops: 2 (dispatched to different execution ports)

Throughput: 2 operations per cycle (if ports available)

0x11: QUAD - Quad Parallel ALU (Same Operation)
Format: Q

Encoding:

json
Type: 0x11
Operation [121:116]: Single operation applied to all 4
FlagSel [97:96]: 00=none, 01=op0, 10=op1, 11=op2

Op 0: Rs1 [95:88], Rs2 [87:80] â†’ Rd [79:72]
Op 1: Rs1 [71:64], Rs2 [63:56] â†’ Rd [55:48]
Op 2: Rs1 [47:40], Rs2 [39:32] â†’ Rd [31:24]
Op 3: Rs1 [23:16], Rs2 [15:8] â†’ Rd [7:0]

Assembly:

asm
QUAD.op [Rs1,Rs2â†’Rd] [Rs1,Rs2â†’Rd] [Rs1,Rs2â†’Rd] [Rs1,Rs2â†’Rd], flags=SEL

Examples:
QUAD.ADD [r0,r1â†’r10] [r2,r3â†’r11] [r4,r5â†’r12] [r6,r7â†’r13], flags=2
  ; r10 = r0 + r1
  ; r11 = r2 + r3
  ; r12 = r4 + r5  (this one updates flags!)
  ; r13 = r6 + r7
  ; All execute in parallel

QUAD.MUL [r20,r21â†’r30] [r22,r23â†’r31] [r24,r25â†’r32] [r26,r27â†’r33], flags=0
  ; 4Ã— parallel multiplies
  ; No flag updates

Execution: All 4 operations execute in parallel using 4 separate ALU units

Constraints:

All 4 operations use SAME opcode
All must be independent (no overlapping destination registers)
Limited to operations with â‰¤3 cycle latency (MUL okay, DIV not supported)
Latency: Operation latency (1-3 cycles depending on op)

Î¼Ops: 4 (all dispatched simultaneously)

Throughput: 4 operations per cycle (maximum theoretical)

Use case: Loop unrolling, array processing, SIMD-like scalar operations

0x12: TRIPLE - Triple Parallel ALU
Format: T

Encoding:

json
Type: 0x12
Op A [121:116], Op B [115:110], Op C [109:104]
FlagSel [97:96]: 00=none, 01=A, 10=B, 11=C

Op A: Rs1 [95:88], Rs2 [87:80] â†’ Rd [79:72]
Op B: Rs1 [71:64], Rs2 [63:56] â†’ Rd [55:48]
Op C: Rs1 [47:40], Rs2 [39:32] â†’ Rd [31:24]

Assembly:

asm
TRIPLE [opA Rs1,Rs2â†’Rd] [opB Rs1,Rs2â†’Rd] [opC Rs1,Rs2â†’Rd], flags=SEL

Examples:
TRIPLE [ADD r1,r2â†’r10] [SUB r3,r4â†’r11] [MUL r5,r6â†’r12], flags=B
  ; Three different operations in parallel
  ; Operation B (SUB) updates flags

Latency: Max(latency_A, latency_B, latency_C)

Î¼Ops: 3

Use case: Balance between DUAL (more flexible ops) and QUAD (more throughput)

GROUP 0x18-0x1F: DATA MOVEMENT
0x18: MOVI - Move Immediate
Format: I

Encoding:

Type: 0x18
Rs [95:88]: Ignored (set to r0)
Rd [87:80]: Destination register
Immediate [79:16]: 64-bit immediate value
FlagUpdate [15:14]: Always 00 (MOVI never updates flags)

Assembly:

asm
MOVI imm64 â†’ Rd

Examples:
MOVI 0x123456789ABCDEF0 â†’ r42
  ; r42 = 0x123456789ABCDEF0

MOVI 0 â†’ r10
  ; r10 = 0 (clear register)

MOVI -1 â†’ r5
  ; r5 = 0xFFFFFFFFFFFFFFFF (all ones)

MOVI 0x7FFFFFFFFFFFFFFF â†’ r20
  ; r20 = largest positive signed 64-bit int

Execution:

c
Rd = sign_extend(immediate[63:0]);

Latency: 1 cycle (immediate available at decode)

Î¼Ops: 1

Note: For values that fit in smaller immediates, compiler may optimize to ALUI with r0 as source.

0x19: MOV - Move Register
Format: R

Encoding:

json
Type: 0x19
Operation [121:116]: Ignored (always 0x00)
Rs1 [95:88]: Source register
Rs2 [87:80]: Ignored (set to r0)
Rd [79:72]: Destination register
FlagUpdate [71:70]: Always 00

Assembly:

asm
MOV Rs â†’ Rd

Examples:
MOV r5 â†’ r10
  ; r10 = r5

MOV r0 â†’ r20
  ; r20 = 0 (move from zero register clears destination)

Execution:

c
Rd = Rs1;

Latency: 0 cycles (register renaming eliminates move)

Î¼Ops: 1 (eliminated during register rename via move elimination)

Note: Modern out-of-order cores implement "move elimination" - MOV instructions are removed during rename by pointing destination to same physical register as source.

0x1A: SWAP - Swap Registers
Format: R

Encoding:

Type: 0x1A
Rs1 [95:88]: First register
Rs2 [87:80]: Second register
Rd [79:72]: Ignored
FlagUpdate [71:70]: Always 00

Assembly:

asm
SWAP Rs1, Rs2

Examples:
SWAP r10, r11
  ; temp = r10
  ; r10 = r11
  ; r11 = temp

Execution:

c
temp = Rs1;
Rs1 = Rs2;
Rs2 = temp;

Latency: 1 cycle

Î¼Ops: 3

Read Rs1, Rs2
Write Rs1 = Rs2
Write Rs2 = old Rs1
Note: In register-renamed architectures, this can be optimized to 0 Î¼Ops by swapping rename table entries.

0x1B: MVPAIR - Move Register Pair
Format: R (extended)

Encoding:

Type: 0x1B
Rs1 [95:88]: Source register 1
Rs2 [87:80]: Source register 2
Rd1 [79:72]: Destination register 1
Rd2 [71:64]: Destination register 2

Assembly:

asm
MVPAIR Rs1, Rs2 â†’ Rd1, Rd2

Examples:
MVPAIR r10, r11 â†’ r20, r21
  ; r20 = r10
  ; r21 = r11
  ; Both moves in parallel

Latency: 0 cycles (move elimination)

Î¼Ops: 2 (but both eliminated via rename)

0x1C: MVQUAD - Move 4 Registers (Parallel)
Format: Q (reused for moves)

Encoding:

json
Type: 0x1C
Src0 [95:88] â†’ Dst0 [79:72]
Src1 [71:64] â†’ Dst1 [55:48]
Src2 [47:40] â†’ Dst2 [31:24]
Src3 [23:16] â†’ Dst3 [7:0]

Assembly:

asm
MVQUAD [Rsâ†’Rd] [Rsâ†’Rd] [Rsâ†’Rd] [Rsâ†’Rd]

Examples:
MVQUAD [r0â†’r10] [r1â†’r11] [r2â†’r12] [r3â†’r13]
  ; Copy r0-r3 to r10-r13 in parallel

Latency: 0 cycles

Î¼Ops: 4 (all eliminated)

Use case: Function prologue/epilogue (save/restore registers)

0x1D: BCAST - Broadcast Immediate
Format: I (extended)

Encoding:

json
Type: 0x1D
Immediate [95:32]: 64-bit immediate
Rd1 [31:24]: Destination register 1
Rd2 [23:16]: Destination register 2
Rd3 [15:8]: Destination register 3
Rd4 [7:0]: Destination register 4

Assembly:

asm
BCAST imm64 â†’ Rd1, Rd2, Rd3, Rd4

Examples:
BCAST 0x123456789ABCDEF0 â†’ r10, r11, r12, r13
  ; r10 = r11 = r12 = r13 = 0x123456789ABCDEF0
  ; All 4 registers loaded with same immediate

Execution:

c
Rd1 = Rd2 = Rd3 = Rd4 = immediate;

Latency: 1 cycle

Î¼Ops: 4 (but all use same immediate decode)

Use case: Initialize multiple registers to same value (zero/sentinel/constant)

GROUP 0x20-0x27: MEMORY LOAD
0x20: LD - Load
Format: M

Encoding:

routeros
Type: 0x20
Size [112:110]: 000=8b, 001=16b, 010=32b, 011=64b
Sign [109]: 0=unsigned, 1=signed
Ordering [108:106]: Memory ordering semantics
Rs_addr [95:88]: Base address register
Rd_data [87:80]: Destination register
Offset [79:16]: 64-bit signed byte offset

Assembly:

asm
LD.size[.sign][.order] [Rs + offset] â†’ Rd

Examples:
LD.64 [r20 + 0x1000] â†’ r10
  ; r10 = Memory[r20 + 4096]
  ; 64-bit load, no sign extension needed

LD.32.S [r15 - 0x100] â†’ r5
  ; r5 = sign_extend(Memory[r15 - 256][31:0])
  ; Load 32-bit signed, sign-extend to 64 bits

LD.8.U [r100] â†’ r3
  ; r3 = zero_extend(Memory[r100][7:0])
  ; Load byte, zero-extend

LD.16.S.ACQ [r50 + 0x200] â†’ r60
  ; r60 = sign_extend(Memory[r50 + 512][15:0])
  ; Load halfword with acquire semantics

Address Calculation:

c
effective_address = Rs_addr + sign_extend(offset);

Execution:

c
EA = Rs_addr + offset;
data = Memory[EA];

switch (size) {
  case 8:  result = sign_or_zero_extend(data[7:0]); break;
  case 16: result = sign_or_zero_extend(data[15:0]); break;
  case 32: result = sign_or_zero_extend(data[31:0]); break;
  case 64: result = data[63:0]; break;
}

Rd_data = result;

Latency:

L1 hit: 4 cycles
L2 hit: 12 cycles
L3 hit: 35 cycles
DRAM: 100-300 cycles

Î¼Ops: 1 (address generation + load)

Memory Ordering:

NORMAL (000):  No ordering guarantees
ACQUIRE (001): Load-acquire (all prior loads complete before this)
SEQ_CST (100): Sequentially consistent

0x21: LDX - Load Indexed
Format: X

Encoding:

json
Type: 0x21
Size [112:110], Sign [109]: Same as LD
Scale [102:96]: 000=Ã—1, 001=Ã—2, 010=Ã—4, 011=Ã—8, 100=Ã—16
Rs_base [95:88]: Base address register
Rs_index [87:80]: Index register
Rd_data [79:72]: Destination register
Offset [71:16]: 56-bit signed byte offset

Assembly:

asm
LDX.size[.sign] [Rs_base + Rs_indexÃ—scale + offset] â†’ Rd

Examples:
LDX.64 [r20 + r5Ã—8 + 0x100] â†’ r10
  ; r10 = Memory[r20 + r5Ã—8 + 256]
  ; Array access: base + indexÃ—element_size + offset

LDX.32.S [r15 + r6Ã—4] â†’ r3
  ; r3 = sign_extend(Memory[r15 + r6Ã—4])
  ; 32-bit array element access

LDX.8.U [r100 + r101Ã—1 + 0] â†’ r102
  ; r102 = Memory[r100 + r101]
  ; Byte array access

Address Calculation:

c
EA = Rs_base + (Rs_index << scale) + sign_extend(offset);

Use case: Array/structure access with compile-time known stride

Latency: Same as LD + 1 cycle for address calculation = 5 cycles (L1 hit)

Î¼Ops: 1 (complex address generation unit)

0x22: LDA - Load Absolute
Format: M (Rs_addr ignored)

Encoding:

json
Type: 0x22
Size [112:110], Sign [109]: Same as LD
Rs_addr [95:88]: Ignored
Rd_data [87:80]: Destination
Offset [79:16]: 64-bit absolute address

Assembly:

asm
LDA.size[.sign] [imm64] â†’ Rd

Examples:
LDA.64 [0x00007FFF12345000] â†’ r10
  ; r10 = Memory[0x00007FFF12345000]
  ; Load from absolute address

LDA.32.S [0x0000000040000000] â†’ r5
  ; r5 = sign_extend(Memory[0x40000000])
  ; Load from fixed address (e.g., MMIO register)

Use case: Access global variables, MMIO registers, fixed addresses

Latency: Same as LD (4 cycles L1 hit)

Î¼Ops: 1

0x23: LDPAIR - Load Pair
Format: M (extended)

Encoding:

json
Type: 0x23
Rs_addr [95:88]: Base address
Rd1 [87:80]: First destination (loaded from [addr])
Rd2 [79:72]: Second destination (loaded from [addr+8])
Offset [71:16]: Signed offset

Assembly:

asm
LDPAIR [Rs + offset] â†’ Rd1, Rd2

Examples:
LDPAIR [r20 + 0x100] â†’ r10, r11
  ; r10 = Memory[r20 + 256]     (8 bytes)
  ; r11 = Memory[r20 + 264]     (8 bytes)
  ; Load two consecutive 64-bit values

Address:

c
EA = Rs_addr + offset;
Rd1 = Memory[EA];
Rd2 = Memory[EA + 8];

Latency: 4 cycles (both loads may hit in same L1 cache line)

Î¼Ops: 2

Use case: Load structure with two 64-bit fields, function return values (if ABI uses 2 registers)

0x24: LDQUAD - Load Quad
Format: M (extended)

Encoding:

Type: 0x24
Rs_addr [95:88]: Base address
Rd1-Rd4 [87:56]: Four consecutive destination registers
Offset [55:16]: Signed offset

Assembly:

asm
LDQUAD [Rs + offset] â†’ Rd1, Rd2, Rd3, Rd4

Examples:
LDQUAD [r20] â†’ r10, r11, r12, r13
  ; Load 32 bytes (4Ã—8 bytes) into 4 registers
  ; r10 = Mem[r20+0]
  ; r11 = Mem[r20+8]
  ; r12 = Mem[r20+16]
  ; r13 = Mem[r20+24]

Latency: 4 cycles (if all fit in single cache line)

Î¼Ops: 4

Use case: Load 256-bit vector, load large structure

0x25: PREFETCH - Prefetch to Cache
Format: M

Encoding:

Type: 0x25
Hint [112:110]: Prefetch hint (temporal/non-temporal)
Rs_addr [95:88]: Base address
Offset [79:16]: Offset

Assembly:

asm
PREFETCH[.hint] [Rs + offset]

Examples:
PREFETCH.T0 [r20 + 0x1000]
  ; Prefetch to L1 cache (temporal hint)

PREFETCH.NTA [r100 + r101Ã—64]
  ; Prefetch non-temporal (bypass L1/L2, go to L3)

Hints:

T0 (000):  Temporal, L1 cache
T1 (001):  Temporal, L2 cache
T2 (010):  Temporal, L3 cache
NTA (011): Non-temporal (streaming, don't pollute cache)

Execution: No architectural effect (may be NOP on some implementations)

Latency: 0 cycles (does not block)

Î¼Ops: 1 (may be dropped if prefetch queue full)

GROUP 0x28-0x2F: MEMORY STORE
0x28: ST - Store
Format: M

Encoding:

json
Type: 0x28
Size [112:110]: Store width
Ordering [108:106]: Memory ordering
Rs_data [95:88]: Source data register
Rd_addr [87:80]: Base address register
Offset [79:16]: Signed offset

Assembly:

asm
ST.size[.order] Rs â†’ [Rd + offset]

Examples:
ST.64 r10 â†’ [r20 + 0x1000]
  ; Memory[r20 + 4096] = r10
  ; Store 64 bits

ST.32 r5 â†’ [r15]
  ; Memory[r15] = r5[31:0]
  ; Store lower 32 bits

ST.8 r3 â†’ [r100 + 0xFF]
  ; Memory[r100 + 255] = r3[7:0]
  ; Store byte

ST.64.REL r50 â†’ [r60 + 0x200]
  ; Memory[r60 + 512] = r50
  ; Store with release semantics

Address Calculation:

c
EA = Rd_addr + sign_extend(offset);

Execution:

c
EA = Rd_addr + offset;

switch (size) {
  case 8:  Memory[EA][7:0] = Rs_data[7:0]; break;
  case 16: Memory[EA][15:0] = Rs_data[15:0]; break;
  case 32: Memory[EA][31:0] = Rs_data[31:0]; break;
  case 64: Memory[EA][63:0] = Rs_data[63:0]; break;
}

Latency: 1 cycle (posted to store buffer, actual memory write later)

Î¼Ops: 1 (address generation + store data)

Memory Ordering:

NORMAL (000):  No ordering
RELEASE (010): Store-release (all prior stores visible before this)
SEQ_CST (100): Sequentially consistent

0x29: STX - Store Indexed
Format: X

Encoding:

json
Type: 0x29
Size [112:110], Ordering [108:106]: Same as ST
Scale [102:96]: Index scale
Rs_data [95:88]: Source data
Rs_base [87:80]: Base address
Rs_index [79:72]: Index register
Offset [71:16]: Offset

Assembly:

asm
STX.size[.order] Rs_data â†’ [Rs_base + Rs_indexÃ—scale + offset]

Examples:
STX.64 r10 â†’ [r20 + r5Ã—8 + 0x100]
  ; Memory[r20 + r5Ã—8 + 256] = r10
  ; Store to array element

STX.32 r3 â†’ [r15 + r6Ã—4]
  ; Memory[r15 + r6Ã—4] = r3[31:0]
  ; Store to 32-bit array

Address:

c
EA = Rs_base + (Rs_index << scale) + offset;

Latency: 1 cycle (to store buffer)

Î¼Ops: 1

0x2A: STA - Store Absolute
Format: M

Encoding:

Type: 0x2A
Size [112:110]: Store width
Rs_data [95:88]: Source data
Offset [79:16]: 64-bit absolute address

Assembly:

asm
STA.size Rs â†’ [imm64]

Examples:
STA.64 r10 â†’ [0x00007FFF12345000]
  ; Memory[0x00007FFF12345000] = r10

STA.32 r5 â†’ [0x0000000040000000]
  ; Memory[0x40000000] = r5[31:0]
  ; Store to MMIO register

Use case: Write to global variables, MMIO registers

Latency: 1 cycle (to store buffer)

Î¼Ops: 1

0x2B: STPAIR - Store Pair
Format: M (extended)

Assembly:

asm
STPAIR Rs1, Rs2 â†’ [Rd + offset]

Examples:
STPAIR r10, r11 â†’ [r20 + 0x100]
  ; Memory[r20 + 256] = r10
  ; Memory[r20 + 264] = r11

Latency: 1 cycle (both to store buffer)

Î¼Ops: 2

0x2C: STQUAD - Store Quad
Format: M (extended)

Assembly:

asm
STQUAD Rs1, Rs2, Rs3, Rs4 â†’ [Rd + offset]

Examples:
STQUAD r10, r11, r12, r13 â†’ [r20]
  ; Store 32 bytes (4Ã—8) to consecutive addresses

Latency: 1 cycle (all to store buffer)

Î¼Ops: 4

0x2D: FLUSH - Flush Cache Line
Format: M

Encoding:

Type: 0x2D
Rs_addr [95:88]: Address register
Offset [79:16]: Offset

Assembly:

asm
FLUSH [Rs + offset]

Examples:
FLUSH [r20 + 0x1000]
  ; Flush cache line containing address r20+4096
  ; Write back if dirty, invalidate

Execution: Cache line containing EA is written back (if dirty) and invalidated

Latency: 10-50 cycles (depends on cache state)

Î¼Ops: 1 (serializing operation)

Use case: DMA buffer management, shared memory synchronization

GROUP 0x30-0x37: ATOMIC OPERATIONS
0x30: AMO - Atomic Memory Operation
Format: A

Encoding:

json
Type: 0x30
AMO Op [121:116]: Operation (SWAP/ADD/AND/OR/XOR/MIN/MAX)
Size [115:113]: 32-bit or 64-bit
Order [112:110]: Memory ordering
Rs_new [95:88]: New value register
Rd_old [87:80]: Destination (receives old value)
Address [79:16]: 64-bit address

Assembly:

asm
AMO.op.size[.order] Rs_new, [address] â†’ Rd_old

Examples:
AMO.ADD.64.SEQ_CST r5, [0x7FFF00001000] â†’ r10
  ; old = Memory[addr]
  ; Memory[addr] += r5  (atomically)
  ; r10 = old
  ; Sequentially consistent

AMO.SWAP.32.ACQ_REL r8, [r20+0x100] â†’ r7
  ; r7 = Memory[r20+256]
  ; Memory[r20+256] = r8
  ; Atomic exchange with acquire-release

AMO.OR.64.RELAXED r15, [r25] â†’ r16
  ; old = Memory[r25]
  ; Memory[r25] |= r15
  ; r16 = old
  ; Relaxed ordering (no sync)

Execution:

c
// Atomic section (uninterruptible)
old_value = Memory[address];
switch (op) {
  case SWAP: new_value = Rs_new; break;
  case ADD:  new_value = old_value + Rs_new; break;
  case SUB:  new_value = old_value - Rs_new; break;
  case AND:  new_value = old_value & Rs_new; break;
  case OR:   new_value = old_value | Rs_new; break;
  case XOR:  new_value = old_value ^ Rs_new; break;
  case MIN:  new_value = min(old_value, Rs_new); break;
  case MAX:  new_value = max(old_value, Rs_new); break;
}
Memory[address] = new_value;
Rd_old = old_value;

Latency: 20-50 cycles (serialized at memory controller)

Î¼Ops: 1 (microarchitecturally complex, may crack into multiple internal ops)

Hardware Requirements:

Cache coherence protocol (MESI/MOESI)
Atomic execution unit
Memory ordering buffers
0x31: CAS - Compare-And-Swap
Format: CAS

Encoding:

json
Type: 0x31
Size [115:113]: 32/64-bit
Rs_new [95:88]: Value to store if comparison succeeds
Rs_cmp [87:80]: Expected value (compare against)
Rd_old [79:72]: Destination (receives actual old value)
Address [71:16]: 56-bit address

Assembly:

asm
CAS.size Rs_new, Rs_cmp, [address] â†’ Rd_old

Examples:
CAS.64 r5, r6, [0x7FFF00001000] â†’ r10
  ; old = Memory[addr]
  ; if (old == r6) Memory[addr] = r5
  ; r10 = old
  ; ZF = (old == r6) ? 1 : 0

CAS.32 r20, r21, [r30+0x100] â†’ r25
  ; old = Memory[r30+256][31:0]
  ; if (old == r21[31:0]) Memory[r30+256] = r20[31:0]
  ; r25 = sign_extend(old)
  ; ZF set on success

Execution:

c
old_value = Memory[address];
if (old_value == Rs_cmp) {
  Memory[address] = Rs_new;
  ZF = 1;  // Success
} else {
  ZF = 0;  // Failure
}
Rd_old = old_value;

Typical usage (lock-free compare-and-swap loop):

asm
retry:
  LD.64 [r20] â†’ r5              ; Load current value
  ALUI.ADD r5, 1 â†’ r6, flags=0  ; Compute new value
  CAS.64 r6, r5, [r20] â†’ r7     ; Try to swap
  BR.NE retry                   ; Retry if failed (ZF=0)

Latency: 25-60 cycles

Î¼Ops: 1 (serializing)

0x32: CAS2 - Double-Width CAS (128-bit)
Format: CAS (extended)

Encoding:

json
Type: 0x32
Rs_new_low [95:88], Rs_new_high [87:80]: 128-bit new value
Rs_cmp_low [79:72], Rs_cmp_high [71:64]: 128-bit expected
Rd_old_low [63:56], Rd_old_high [55:48]: 128-bit old value
Address [47:16]: Address (must be 16-byte aligned)

Assembly:

asm
CAS2 Rs_new_low, Rs_new_high, Rs_cmp_low, Rs_cmp_high, [addr] â†’ Rd_old_low, Rd_old_high

Examples:
CAS2 r10, r11, r12, r13, [r20] â†’ r30, r31
  ; Compare-and-swap 128 bits atomically
  ; if (Mem[r20:r20+15] == {r13,r12}) Mem[r20:r20+15] = {r11,r10}
  ; {r31,r30} = old value

Use case: Lock-free data structures with ABA problem mitigation (pointer + counter)

Latency: 30-80 cycles

Î¼Ops: 1 (very complex microarchitectural implementation)

0x33: LL - Load-Linked
Format: M

Encoding:

Type: 0x33
Size [112:110]: Load width
Rs_addr [95:88]: Address register
Rd_data [87:80]: Destination
Offset [79:16]: Offset

Assembly:

asm
LL.size [Rs + offset] â†’ Rd

Examples:
LL.64 [r20] â†’ r10
  ; r10 = Memory[r20]
  ; Mark address for exclusive monitoring

Execution:

c
Rd_data = Memory[Rs_addr + offset];
mark_exclusive(Rs_addr + offset);  // Hardware monitors this address

Latency: 5 cycles (L1 hit + exclusive mark setup)

Î¼Ops: 1

0x34: SC - Store-Conditional
Format: M

Encoding:

json
Type: 0x34
Size [112:110]: Store width
Rs_data [95:88]: Source data
Rd_addr [87:80]: Address register
Rd_status [79:72]: Status register (0=success, 1=fail)
Offset [71:16]: Offset

Assembly:

asm
SC.size Rs_data, [Rd_addr + offset] â†’ Rd_status

Examples:
SC.64 r10, [r20] â†’ r5
  ; if (exclusive_monitor_valid(r20)) {
  ;   Memory[r20] = r10
  ;   r5 = 0 (success)
  ; } else {
  ;   r5 = 1 (failure, retry needed)
  ; }

Execution:

c
if (exclusive_monitor_valid(Rd_addr + offset)) {
  Memory[Rd_addr + offset] = Rs_data;
  Rd_status = 0;  // Success
  clear_exclusive(Rd_addr + offset);
} else {
  Rd_status = 1;  // Failure
}

LL/SC usage pattern:

asm
retry:
  LL.64 [r20] â†’ r5               ; Load-linked
  ALUI.ADD r5, 1 â†’ r6, flags=0   ; Compute new value
  SC.64 r6, [r20] â†’ r7           ; Store-conditional
  CMP.SUB r7, r0                 ; Check if SC succeeded
  BR.NE retry                    ; Retry if failed

Latency: SC: 1-50 cycles (1 if success, 50+ if exclusive monitor invalidated)

Î¼Ops: 1

Note: LL/SC is preferred over CAS in some architectures for scalability (less memory traffic on contention).

0x35: AMOMAX - Atomic Max/Min
Format: A

Encoding:

Type: 0x35
Operation [121:116]: MIN/MAX/MINU/MAXU
Size, Order, registers: Same as AMO

Assembly:

asm
AMOMAX.op.size[.order] Rs_new, [address] â†’ Rd_old

Examples:
AMOMAX.MAX.64 r5, [r20] â†’ r10
  ; old = Memory[r20]
  ; Memory[r20] = max(old, r5)  (signed comparison)
  ; r10 = old

AMOMAX.MINU.32 r8, [0x7FFF1000] â†’ r9
  ; Atomic unsigned min

Use case: Concurrent maximum/minimum tracking (e.g., high-water mark)

Latency: 20-50 cycles

Î¼Ops: 1

GROUP 0x38-0x3F: SIMD/VECTOR
0x38: VALU - Vector ALU
Format: V

Encoding:

json
Type: 0x38
Operation [121:116]: Vector operation (same encoding as scalar ALU)
ElemWidth [115:113]: 001=8b, 010=16b, 011=32b, 100=64b
Rs1 [95:88]: First source vector
Rs2 [87:80]: Second source vector
Rd [79:72]: Destination vector

Assembly:

asm
VALU.op.width Rs1, Rs2 â†’ Rd

Examples:
VALU.ADD.32 r10, r11 â†’ r12
  ; r12[31:0]  = r10[31:0]  + r11[31:0]
  ; r12[63:32] = r10[63:32] + r11[63:32]
  ; Two 32-bit additions in parallel (SIMD within register)

VALU.MUL.16 r5, r6 â†’ r7
  ; r7[15:0]  = r5[15:0]  Ã— r6[15:0]
  ; r7[31:16] = r5[31:16] Ã— r6[31:16]
  ; r7[47:32] = r5[47:32] Ã— r6[47:32]
  ; r7[63:48] = r5[63:48] Ã— r6[63:48]
  ; Four 16-bit multiplies in parallel

VALU.AND.8 r20, r21 â†’ r22
  ; Eight 8-bit AND operations in parallel

Execution: Element-wise operation on packed data within 64-bit register

Latency: Same as scalar equivalent (1-3 cycles depending on op)

Î¼Ops: 1 (SIMD execution unit)

Throughput: 2-8 operations per cycle (depending on element width)

0x39: VFMA - Vector Fused Multiply-Add
Format: V (extended to 3 sources)

Encoding:

json
Type: 0x39
ElemWidth [115:113]: Element width
Rs1 [95:88]: Multiplicand A
Rs2 [87:80]: Multiplicand B
Rs3 [79:72]: Addend C
Rd [71:64]: Destination (AÃ—B + C)

Assembly:

asm
VFMA.width Rs1, Rs2, Rs3 â†’ Rd

Examples:
VFMA.32 r10, r11, r12 â†’ r13
  ; r13[31:0]  = r10[31:0]  Ã— r11[31:0]  + r12[31:0]
  ; r13[63:32] = r10[63:32] Ã— r11[63:32] + r12[63:32]
  ; Two 32-bit FMAs in parallel

Latency: 4 cycles (pipelined)

Î¼Ops: 1

Use case: Dot product, matrix multiply kernels

0x3A: VRED - Vector Reduction
Format: V

Encoding:

Type: 0x3A
Operation [121:116]: Reduction operation (SUM/MIN/MAX/AND/OR/XOR)
ElemWidth [115:113]: Element width
Rs [95:88]: Source vector
Rd [87:80]: Destination scalar (result of reduction)

Assembly:

asm
VRED.op.width Rs â†’ Rd

Examples:
VRED.SUM.32 r10 â†’ r11
  ; r11 = r10[31:0] + r10[63:32]
  ; Horizontal sum of two 32-bit elements

VRED.SUM.16 r5 â†’ r6
  ; r6 = r5[15:0] + r5[31:16] + r5[47:32] + r5[63:48]
  ; Sum of four 16-bit elements

VRED.MAX.8 r20 â†’ r21
  ; r21 = max(r20[7:0], r20[15:8], ..., r20[63:56])
  ; Maximum of eight 8-bit elements

Latency: 3-6 cycles (depends on element count)

Î¼Ops: 1 (reduction tree internally)

0x3B: VSHUFFLE - Vector Shuffle
Format: V (with immediate shuffle mask)

Encoding:

json
Type: 0x3B
Shuffle mask [121:96]: 26-bit shuffle control
ElemWidth [115:113]: Element width
Rs1 [95:88]: Source vector 1
Rs2 [87:80]: Source vector 2
Rd [79:72]: Destination

Assembly:

asm
VSHUFFLE.width Rs1, Rs2, mask â†’ Rd

Examples:
VSHUFFLE.32 r10, r11, 0b10_00_11_01 â†’ r12
  ; r12[31:0]  = r11[31:0]     (element 1 from Rs2)
  ; r12[63:32] = r11[63:32]    (element 3 from Rs2)
  ; (Shuffle/permute 32-bit elements)

Use case: Lane swizzling, transposition, data reorganization

Latency: 2 cycles

Î¼Ops: 1

0x3C: VEXTRACT - Extract Vector Element
Format: V

Encoding:

Type: 0x3C
Index [121:118]: Element index to extract
ElemWidth [115:113]: Element width
Rs [95:88]: Source vector
Rd [87:80]: Destination scalar

Assembly:

asm
VEXTRACT.width Rs, index â†’ Rd

Examples:
VEXTRACT.32 r10, 0 â†’ r11
  ; r11 = r10[31:0]
  ; Extract first 32-bit element

VEXTRACT.16 r5, 2 â†’ r6
  ; r6 = zero_extend(r5[47:32])
  ; Extract third 16-bit element

Latency: 1 cycle (shift + mask)

Î¼Ops: 1

0x3D: VINSERT - Insert Vector Element
Format: V

Encoding:

json
Type: 0x3D
Index [121:118]: Element index to insert into
ElemWidth [115:113]: Element width
Rs_scalar [95:88]: Scalar value to insert
Rs_vector [87:80]: Source vector (other elements preserved)
Rd [79:72]: Destination vector

Assembly:

asm
VINSERT.width Rs_scalar, Rs_vector, index â†’ Rd

Examples:
VINSERT.32 r10, r11, 1 â†’ r12
  ; r12 = r11 with r12[63:32] = r10[31:0]
  ; Insert scalar into second 32-bit element

Latency: 1 cycle

Î¼Ops: 1

0x3E: VBCAST - Broadcast Scalar to Vector
Format: V

Encoding:

Type: 0x3E
ElemWidth [115:113]: Element width
Rs_scalar [95:88]: Scalar source
Rd [87:80]: Destination vector

Assembly:

asm
VBCAST.width Rs_scalar â†’ Rd

Examples:
VBCAST.32 r5 â†’ r10
  ; r10[31:0]  = r5[31:0]
  ; r10[63:32] = r5[31:0]
  ; Replicate 32-bit value to both lanes

VBCAST.16 r20 â†’ r21
  ; r21[15:0]  = r20[15:0]
  ; r21[31:16] = r20[15:0]
  ; r21[47:32] = r20[15:0]
  ; r21[63:48] = r20[15:0]
  ; Replicate 16-bit value to four lanes

Latency: 1 cycle

Î¼Ops: 1

0x3F: VCMP - Vector Compare
Format: V

Encoding:

gauss
Type: 0x3F
Comparison [121:116]: EQ/NE/LT/LE/GT/GE (signed/unsigned variants)
ElemWidth [115:113]: Element width
Rs1 [95:88]: First vector
Rs2 [87:80]: Second vector
Rd [79:72]: Destination mask vector

Assembly:

asm
VCMP.cond.width Rs1, Rs2 â†’ Rd

Examples:
VCMP.EQ.32 r10, r11 â†’ r12
  ; r12[31:0]  = (r10[31:0]  == r11[31:0])  ? 0xFFFFFFFF : 0
  ; r12[63:32] = (r10[63:32] == r11[63:32]) ? 0xFFFFFFFF : 0
  ; Generate mask vector for element-wise equality

VCMP.LT.16 r5, r6 â†’ r7
  ; Four 16-bit comparisons, generate four 16-bit masks

Execution: Each element comparison produces all-ones (true) or all-zeros (false)

Latency: 1 cycle

Î¼Ops: 1

Use case: Predicated SIMD operations, masked stores

GROUP 0x40-0x47: SYSTEM/CONTROL
0x40: FENCE - Memory Fence
Format: S

Encoding:

Type: 0x40
Sub-op [121:116]:
  0x00: FENCE.R   (load fence)
  0x01: FENCE.W   (store fence)
  0x02: FENCE.RW  (full fence)
  0x03: FENCE.SYNC (synchronize)

Assembly:

asm
FENCE[.type]

Examples:
FENCE.R
  ; All prior loads complete before any subsequent loads

FENCE.W
  ; All prior stores complete before any subsequent stores

FENCE.RW
  ; Full memory barrier (all prior memory ops complete)

FENCE.SYNC
  ; Synchronize all cores (heavyweight barrier)

Execution: Stalls pipeline until all prior memory operations (of specified type) complete

Latency: 5-100 cycles (depends on memory subsystem state)

Î¼Ops: 1 (serializing)

Use case: Synchronization primitives, memory ordering enforcement

0x41: CSRRW - CSR Read-Write
Format: S

Encoding:

Type: 0x41
Rs [95:88]: Source register (value to write)
Rd [87:80]: Destination register (receives old CSR value)
CSR Address [79:16]: 64-bit CSR address (lower 12 bits used)

Assembly:

asm
CSRRW Rs, csr_addr â†’ Rd

Examples:
CSRRW r5, 0x300 â†’ r10
  ; r10 = CSR[0x300]  (read old value)
  ; CSR[0x300] = r5   (write new value)
  ; Atomic read-modify-write

Latency: 10 cycles (serializing)

Î¼Ops: 1

0x42: CSRR - CSR Read-Only
Format: S

Encoding:

Type: 0x42
Rd [87:80]: Destination
CSR Address [79:16]: CSR address

Assembly:

asm
CSRR csr_addr â†’ Rd

Examples:
CSRR 0x300 â†’ r10
  ; r10 = CSR[0x300]
  ; Read mstatus register

Latency: 5 cycles

Î¼Ops: 1

0x43: CSRW - CSR Write-Only
Format: S

Encoding:

Type: 0x43
Rs [95:88]: Source value
CSR Address [79:16]: CSR address

Assembly:

asm
CSRW Rs â†’ csr_addr

Examples:
CSRW r5 â†’ 0x305
  ; CSR[0x305] = r5
  ; Write to mtvec (trap vector base)

Latency: 10 cycles (serializing)

Î¼Ops: 1

0x44: SYSCALL - System Call
Format: S

Encoding:

Type: 0x44
Immediate [79:16]: 64-bit syscall number

Assembly:

asm
SYSCALL imm64

Examples:
SYSCALL 0x01
  ; Invoke system call #1 (e.g., write)
  ; Arguments in r10-r17 (by ABI convention)
  ; Return value in r10

Execution:

c
// Save state
CSR[EPC] = PC + 16;  // Save return address
CSR[CAUSE] = SYSCALL;
CSR[STATUS] = update_privilege_mode(SUPERVISOR);

// Jump to trap handler
PC = CSR[TVEC];

Latency: 50-200 cycles (context switch overhead)

Î¼Ops: 1 (microcode assist)

0x45: BREAK - Breakpoint
Format: S

Assembly:

asm
BREAK

Examples:
BREAK
  ; Trigger breakpoint exception
  ; Debugger takes control

Execution: Raises breakpoint exception, transfers to debugger

Latency: Exception (unpredictable)

Î¼Ops: 1

0x46: HALT - Halt Processor
Format: S

Assembly:

asm
HALT

Examples:
HALT
  ; Stop instruction fetch
  ; Enter low-power state
  ; Resume on interrupt

Execution: Halts processor until interrupt arrives

Latency: N/A (blocking)

Î¼Ops: 1

Use case: Power management, idle loops

0x47: ERET - Exception Return
Format: S

Assembly:

asm
ERET

Examples:
ERET
  ; PC = CSR[EPC]
  ; Restore privilege mode
  ; Return from exception/interrupt

Execution:

c
PC = CSR[EPC];
restore_privilege_mode();
restore_interrupt_enable();

Latency: 20 cycles (pipeline flush + state restore)

Î¼Ops: 1 (microcode)

GROUP 0x48-0x4F: BIT MANIPULATION
0x48: BITOPS - Bit Operations
Format: R

Encoding:

clojure
Type: 0x48
Operation [121:116]:
  0x00: POPCNT  (population count)
  0x01: CLZ     (count leading zeros)
  0x02: CTZ     (count trailing zeros)
  0x03: BSWAP   (byte swap)
  0x04: BITREV  (bit reversal)
  0x05: PARITY  (parity)

Rs [95:88]: Source
Rd [87:80]: Destination

Assembly:

asm
BITOPS.op Rs â†’ Rd

Examples:
BITOPS.POPCNT r5 â†’ r10
  ; r10 = number of 1-bits in r5

BITOPS.CLZ r20 â†’ r21
  ; r21 = number of leading zeros in r20

BITOPS.CTZ r30 â†’ r31
  ; r31 = number of trailing zeros in r30

BITOPS.BSWAP r1 â†’ r2
  ; r2 = byte-swapped r1
  ; r2[63:56] = r1[7:0], r2[55:48] = r1[15:8], etc.

BITOPS.BITREV r10 â†’ r11
  ; r11 = bit-reversed r10
  ; r11[63] = r10[0], r11[62] = r10[1], etc.

Latency:

POPCNT/CLZ/CTZ: 3 cycles
BSWAP: 1 cycle
BITREV: 2 cycles

Î¼Ops: 1

0x49: BITFIELD - Bit Field Extract/Insert
Format: R (extended with immediate)

Encoding:

json
Type: 0x49
Operation [121:116]: 0x00=BFEXT, 0x01=BFINS
Start [115:110]: Start bit position (0-63)
Length [109:104]: Field length (1-64 bits)
Rs [95:88]: Source
Rd [87:80]: Destination (or base for insert)

Assembly:

asm
BITFIELD.BFEXT Rs, start, length â†’ Rd
BITFIELD.BFINS Rs, Rd, start, length â†’ Rd

Examples:
BITFIELD.BFEXT r5, 8, 16 â†’ r10
  ; r10 = zero_extend(r5[23:8])
  ; Extract bits 8-23 (16 bits)

BITFIELD.BFINS r20, r21, 32, 8 â†’ r21
  ; r21[39:32] = r20[7:0]
  ; Insert 8 bits from r20 into r21 at position 32

Latency: 2 cycles

Î¼Ops: 1

0x4A: PDEP - Parallel Bit Deposit
Format: R

Encoding:

Type: 0x4A
Rs1 [95:88]: Source bits
Rs2 [87:80]: Mask
Rd [79:72]: Destination

Assembly:

asm
PDEP Rs1, Rs2 â†’ Rd

Examples:
PDEP r5, r6 â†’ r10
  ; Deposit bits from r5 into positions specified by r6 mask
  ; (BMI2 PDEP equivalent)

Execution: Scatters bits from Rs1 to bit positions where Rs2 has 1s

Latency: 3 cycles

Î¼Ops: 1

Use case: Bit packing, Morton codes, hash tables

0x4B: PEXT - Parallel Bit Extract
Format: R

Encoding:

Type: 0x4B
Rs1 [95:88]: Source
Rs2 [87:80]: Mask
Rd [79:72]: Destination

Assembly:

asm
PEXT Rs1, Rs2 â†’ Rd

Examples:
PEXT r5, r6 â†’ r10
  ; Extract bits from r5 where r6 mask has 1s
  ; Pack extracted bits into r10 (right-justified)

Execution: Gathers bits from Rs1 positions where Rs2 has 1s

Latency: 3 cycles

Î¼Ops: 1

0x4C: CRC - CRC Calculation
Format: R (extended)

Encoding:

Type: 0x4C
Polynomial [121:116]: CRC polynomial selector
  0x00: CRC32
  0x01: CRC32C (Castagnoli)
  0x02: CRC64
  0x03: CRC-CCITT

Rs_data [95:88]: Data to hash
Rs_accumulator [87:80]: Previous CRC value
Rd [79:72]: New CRC value

Assembly:

asm
CRC.poly Rs_data, Rs_accumulator â†’ Rd

Examples:
CRC.CRC32C r5, r10 â†’ r10
  ; r10 = crc32c_update(r10, r5)
  ; Update CRC32C with 8 bytes from r5

Latency: 3 cycles

Î¼Ops: 1

Use case: Checksums, hash functions, data integrity

GROUP 0x50-0x57: FLOATING POINT
0x50: FP2 - Dual Floating-Point Operations
Format: D (reused for FP)

Encoding:

json
Type: 0x50
Op A [121:116]: FP operation for first pair
Op B [115:110]: FP operation for second pair
Precision [109:108]: 00=single, 01=double

Op A: Rs1 [95:88], Rs2 [87:80] â†’ Rd [79:72]
Op B: Rs1 [71:64], Rs2 [63:56] â†’ Rd [55:48]

Assembly:

asm
FP2.prec [opA Rs1,Rs2â†’Rd] [opB Rs1,Rs2â†’Rd]

Examples:
FP2.DP [FADD r10,r11â†’r12] [FMUL r13,r14â†’r15]
  ; r12 = r10 + r11  (double-precision FP add)
  ; r15 = r13 Ã— r14  (double-precision FP mul)
  ; Both operations in parallel

FP Operations:

0x00: FADD   (addition)
0x01: FSUB   (subtraction)
0x02: FMUL   (multiplication)
0x03: FDIV   (division)
0x04: FSQRT  (square root)
0x05: FMIN   (minimum)
0x06: FMAX   (maximum)
0x07: FABS   (absolute value)
0x08: FNEG   (negation)

Latency:

FADD/FSUB: 4 cycles
FMUL: 5 cycles
FDIV: 15 cycles (SP), 23 cycles (DP)
FSQRT: 18 cycles (SP), 28 cycles (DP)

Î¼Ops: 2 (both to FP units)

0x51: FPALU - Single FP Operation
Format: R

Encoding:

json
Type: 0x51
Operation [121:116]: FP operation
Precision [115:114]: 00=single, 01=double
Rs1 [95:88], Rs2 [87:80] â†’ Rd [79:72]

Assembly:

asm
FPALU.op.prec Rs1, Rs2 â†’ Rd

Examples:
FPALU.FADD.DP r10, r11 â†’ r12
  ; r12 = r10 + r11 (double-precision)

FPALU.FMUL.SP r5, r6 â†’ r7
  ; r7 = r5 Ã— r6 (single-precision, uses lower 32 bits)

Latency: Same as FP2

Î¼Ops: 1

0x52: FPFMA - FP Fused Multiply-Add
Format: R (extended to 3 sources)

Encoding:

json
Type: 0x52
Precision [115:114]: Single/double
Rs1 [95:88]: Multiplicand A
Rs2 [87:80]: Multiplicand B
Rs3 [79:72]: Addend C
Rd [71:64]: Destination (AÃ—B + C)

Assembly:

asm
FPFMA.prec Rs1, Rs2, Rs3 â†’ Rd

Examples:
FPFMA.DP r10, r11, r12 â†’ r13
  ; r13 = r10 Ã— r11 + r12
  ; Fused multiply-add (single rounding)

Latency: 5 cycles

Î¼Ops: 1

Advantage: Single rounding (more accurate than separate MUL+ADD)

0x53: FPCMP - FP Compare
Format: R

Encoding:

json
Type: 0x53
Comparison [121:116]: EQ/LT/LE/UNORDERED
Precision [115:114]: Single/double
Rs1 [95:88], Rs2 [87:80]
Rd [79:72]: Result (0 or 1)

Assembly:

asm
FPCMP.cond.prec Rs1, Rs2 â†’ Rd

Examples:
FPCMP.LT.DP r10, r11 â†’ r12
  ; r12 = (r10 < r11) ? 1 : 0
  ; NaN handling: returns 0 if either operand is NaN

FPCMP.UNORDERED.DP r5, r6 â†’ r7
  ; r7 = (isNaN(r5) || isNaN(r6)) ? 1 : 0

Latency: 3 cycles

Î¼Ops: 1

0x54: FPCONV - FP Conversion
Format: R

Encoding:

pgsql
Type: 0x54
Conversion [121:116]:
  0x00: I64_TO_FP64 (int64 â†’ double)
  0x01: FP64_TO_I64 (double â†’ int64)
  0x02: I32_TO_FP32 (int32 â†’ float)
  0x03: FP32_TO_I32 (float â†’ int32)
  0x04: FP32_TO_FP64 (float â†’ double)
  0x05: FP64_TO_FP32 (double â†’ float)

Rs [95:88]: Source
Rd [87:80]: Destination

Assembly:

asm
FPCONV.type Rs â†’ Rd

Examples:
FPCONV.I64_TO_FP64 r10 â†’ r11
  ; r11 = (double)r10
  ; Convert signed int64 to double

FPCONV.FP64_TO_I64 r5 â†’ r6
  ; r6 = (int64_t)r5
  ; Convert double to int64 (truncate toward zero)

FPCONV.FP32_TO_FP64 r20 â†’ r21
  ; r21 = (double)r20[31:0]
  ; Widen float to double

Latency: 4-6 cycles

Î¼Ops: 1

0x55: FPSQRT - FP Square Root
Format: R

Encoding:

Type: 0x55
Precision [115:114]: Single/double
Rs [95:88]: Source
Rd [87:80]: Destination (âˆšRs)

Assembly:

asm
FPSQRT.prec Rs â†’ Rd

Examples:
FPSQRT.DP r10 â†’ r11
  ; r11 = âˆšr10 (double-precision)

Latency: 18 cycles (SP), 28 cycles (DP)

Î¼Ops: 1 (not pipelined, serializes)

0x56: FPDIV - FP Division
Format: R

Encoding:

Type: 0x56
Precision [115:114]: Single/double
Rs1 [95:88]: Dividend
Rs2 [87:80]: Divisor
Rd [79:72]: Quotient (Rs1 / Rs2)

Assembly:

asm
FPDIV.prec Rs1, Rs2 â†’ Rd

Examples:
FPDIV.DP r10, r11 â†’ r12
  ; r12 = r10 / r11 (double-precision)

Latency: 15 cycles (SP), 23 cycles (DP)

Î¼Ops: 1 (not pipelined)

0x57: FPCLASS - FP Classify
Format: R

Encoding:

Type: 0x57
Precision [115:114]: Single/double
Rs [95:88]: FP value to classify
Rd [87:80]: Classification result (bitmask)

Assembly:

asm
FPCLASS.prec Rs â†’ Rd

Examples:
FPCLASS.DP r10 â†’ r11
  ; r11 = classification bitmask
  ; Bit 0: Negative infinity
  ; Bit 1: Negative normal
  ; Bit 2: Negative subnormal
  ; Bit 3: Negative zero
  ; Bit 4: Positive zero
  ; Bit 5: Positive subnormal
  ; Bit 6: Positive normal
  ; Bit 7: Positive infinity
  ; Bit 8: Signaling NaN
  ; Bit 9: Quiet NaN

Latency: 2 cycles

Î¼Ops: 1

Use case: Exception handling, algorithm selection based on FP value type

GROUP 0x58-0x5F: SPECIAL PURPOSE
0x58: CRYPTO - Cryptographic Operations
Format: R (extended)

Encoding:

Type: 0x58
Operation [121:116]:
  0x00: AES_ENC    (AES encrypt round)
  0x01: AES_DEC    (AES decrypt round)
  0x02: SHA256_RND (SHA-256 round)
  0x03: SHA512_RND (SHA-512 round)

Rs1 [95:88]: State
Rs2 [87:80]: Round key / data
Rd [79:72]: New state

Assembly:

asm
CRYPTO.op Rs1, Rs2 â†’ Rd

Examples:
CRYPTO.AES_ENC r10, r11 â†’ r12
  ; r12 = AES_encrypt_round(r10, r11)
  ; One round of AES encryption

CRYPTO.SHA256_RND r5, r6 â†’ r7
  ; r7 = SHA256_round(r5, r6)
  ; One round of SHA-256 compression

Latency: 3-5 cycles (pipelined)

Î¼Ops: 1

Use case: Accelerated AES-NI equivalent, SHA acceleration

0x59: COMPRESS - Compression Primitives
Format: R (extended)

Encoding:

Type: 0x59
Operation [121:116]:
  0x00: LZ77_MATCH (find longest match)
  0x01: HUFFMAN_ENC (Huffman encode)
  0x02: RLE (run-length encode)

Rs1 [95:88]: Data/state
Rs2 [87:80]: Dictionary/table
Rd [79:72]: Result

Assembly:

asm
COMPRESS.op Rs1, Rs2 â†’ Rd

Examples:
COMPRESS.LZ77_MATCH r10, r11 â†’ r12
  ; r12 = find_longest_match(r10, r11)
  ; Returns (length, offset) packed

Latency: 5-10 cycles

Î¼Ops: 1

1:29 PM
This response was limited because it hit the maximum output tokens allowed.

Please continue

1:36 PM

Claude-Sonnet-4.5


GROUP 0x58-0x5F: SPECIAL PURPOSE (continued)
0x5A: NEURAL - Neural Network Operations
Format: R (extended for matrix/vector ops)

Encoding:

clojure
Type: 0x5A
Operation [121:116]:
  0x00: DOT8     (8-element dot product, INT8)
  0x01: DOT16    (16-element dot product, INT8)
  0x02: CONV3x3  (3Ã—3 convolution primitive)
  0x03: POOL2x2  (2Ã—2 max pooling)
  0x04: RELU     (ReLU activation)
  0x05: SIGMOID  (Sigmoid activation)
  0x06: QUANTIZE (FPâ†’INT8 quantization)
  0x07: DEQUANT  (INT8â†’FP dequantization)

Rs1 [95:88]: Vector/matrix A
Rs2 [87:80]: Vector/matrix B
Rd [79:72]: Result

Assembly:

asm
NEURAL.op Rs1, Rs2 â†’ Rd

Examples:
NEURAL.DOT8 r10, r11 â†’ r12
  ; r12 = r10[7:0] Ã— r11[7:0] + 
  ;       r10[15:8] Ã— r11[15:8] + ... +
  ;       r10[63:56] Ã— r11[63:56]
  ; 8Ã— INT8 multiply-accumulate
  ; Result accumulated to 32-bit or 64-bit

NEURAL.RELU r5 â†’ r6
  ; r6 = max(r5, 0)
  ; ReLU activation (vectorized for packed elements)

NEURAL.QUANTIZE r20 â†’ r21
  ; r21 = quantize_fp32_to_int8(r20)
  ; Convert FP32 to INT8 with scaling

Execution:

c
// DOT8 example
int32_t result = 0;
for (int i = 0; i < 8; i++) {
  int8_t a = (Rs1 >> (i*8)) & 0xFF;
  int8_t b = (Rs2 >> (i*8)) & 0xFF;
  result += a * b;
}
Rd = result;

Latency:

DOT8/DOT16: 5 cycles (pipelined)
CONV3x3: 8 cycles
POOL2x2: 3 cycles
RELU: 1 cycle
QUANTIZE/DEQUANT: 3 cycles

Î¼Ops: 1

Throughput: 1 operation per cycle (with dedicated neural engine)

Use case: Deep learning inference, quantized neural networks, edge AI

0x5B: MATRIX - Matrix Operations
Format: R (extended with dimension parameters)

Encoding:

json
Type: 0x5B
Operation [121:116]:
  0x00: GEMM_4x4   (4Ã—4 matrix multiply)
  0x01: GEMM_8x8   (8Ã—8 matrix multiply, INT8)
  0x02: TRANSPOSE  (matrix transpose)
  0x03: OUTER      (outer product)

Dimensions [115:108]: Matrix dimensions encoded
Rs1 [95:88]: Matrix A pointer
Rs2 [87:80]: Matrix B pointer
Rd [79:72]: Result matrix pointer

Assembly:

asm
MATRIX.op Rs1, Rs2 â†’ Rd

Examples:
MATRIX.GEMM_4x4 r10, r11 â†’ r12
  ; Perform 4Ã—4 matrix multiply
  ; r10 points to matrix A (4Ã—4, 16 elements)
  ; r11 points to matrix B (4Ã—4, 16 elements)
  ; r12 points to result matrix C (4Ã—4)
  ; C = A Ã— B

MATRIX.TRANSPOSE r5 â†’ r6
  ; In-register transpose for packed data

Note: These operations typically work with memory operands (pointers in registers) rather than direct register data due to size constraints.

Latency: 10-50 cycles (depends on matrix size and cache behavior)

Î¼Ops: 1 (microcode expansion to many internal operations)

Use case: Linear algebra, scientific computing, BLAS acceleration

ğŸ“Š CONTROL AND STATUS REGISTERS (CSRs)
CSR Address Space
crmsh
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ SUPRAX CSR Map (12-bit address space, 0x000-0xFFF)                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ 0x000-0x0FF: User-Mode CSRs (Unprivileged)                              â•‘
â•‘   0x000  USTATUS    User status register                                â•‘
â•‘   0x001  UIE        User interrupt enable                               â•‘
â•‘   0x002  UTVEC      User trap vector base                               â•‘
â•‘   0x004  USCRATCH   User scratch register                               â•‘
â•‘   0x005  UEPC       User exception PC                                   â•‘
â•‘   0x006  UCAUSE     User exception cause                                â•‘
â•‘   0x007  UTVAL      User trap value                                     â•‘
â•‘   0x008  UIP        User interrupt pending                              â•‘
â•‘   0x040  UCYCLE     User cycle counter                                  â•‘
â•‘   0x041  UTIME      User time counter                                   â•‘
â•‘   0x042  UINSTRET   User instructions retired                           â•‘
â•‘   0x043-0x05F       User performance counters (29 counters)             â•‘
â•‘                                                                          â•‘
â•‘ 0x100-0x1FF: Supervisor-Mode CSRs                                       â•‘
â•‘   0x100  SSTATUS    Supervisor status                                   â•‘
â•‘   0x101  SIE        Supervisor interrupt enable                         â•‘
â•‘   0x102  STVEC      Supervisor trap vector base                         â•‘
â•‘   0x103  SCOUNTEREN Supervisor counter enable                           â•‘
â•‘   0x104  SSCRATCH   Supervisor scratch register                         â•‘
â•‘   0x105  SEPC       Supervisor exception PC                             â•‘
â•‘   0x106  SCAUSE     Supervisor exception cause                          â•‘
â•‘   0x107  STVAL      Supervisor trap value                               â•‘
â•‘   0x108  SIP        Supervisor interrupt pending                        â•‘
â•‘   0x180  SATP       Supervisor address translation/protection           â•‘
â•‘                                                                          â•‘
â•‘ 0x300-0x3FF: Machine-Mode CSRs (Highest Privilege)                      â•‘
â•‘   0x300  MSTATUS    Machine status                                      â•‘
â•‘   0x301  MISA       Machine ISA and extensions                          â•‘
â•‘   0x302  MEDELEG    Machine exception delegation                        â•‘
â•‘   0x303  MIDELEG    Machine interrupt delegation                        â•‘
â•‘   0x304  MIE        Machine interrupt enable                            â•‘
â•‘   0x305  MTVEC      Machine trap vector base                            â•‘
â•‘   0x306  MCOUNTEREN Machine counter enable                              â•‘
â•‘   0x310  MSTATUSH   Upper 32 bits of MSTATUS (RV32 only)                â•‘
â•‘   0x320  MCOUNTINHIBIT  Counter inhibit register                        â•‘
â•‘   0x340  MSCRATCH   Machine scratch register                            â•‘
â•‘   0x341  MEPC       Machine exception PC                                â•‘
â•‘   0x342  MCAUSE     Machine exception cause                             â•‘
â•‘   0x343  MTVAL      Machine trap value                                  â•‘
â•‘   0x344  MIP        Machine interrupt pending                           â•‘
â•‘                                                                          â•‘
â•‘ 0x3A0-0x3AF: Physical Memory Protection (16 entries)                    â•‘
â•‘   0x3A0  PMPCFG0    PMP configuration register 0                        â•‘
â•‘   0x3A1  PMPCFG1    PMP configuration register 1                        â•‘
â•‘   0x3A2  PMPCFG2    PMP configuration register 2                        â•‘
â•‘   0x3A3  PMPCFG3    PMP configuration register 3                        â•‘
â•‘   0x3B0  PMPADDR0   PMP address register 0                              â•‘
â•‘   0x3B1  PMPADDR1   PMP address register 1                              â•‘
â•‘   ...               (continues to PMPADDR15)                            â•‘
â•‘   0x3BF  PMPADDR15  PMP address register 15                             â•‘
â•‘                                                                          â•‘
â•‘ 0x7A0-0x7AF: Debug/Trace Registers                                      â•‘
â•‘   0x7A0  TSELECT    Trigger select                                      â•‘
â•‘   0x7A1  TDATA1     Trigger data 1                                      â•‘
â•‘   0x7A2  TDATA2     Trigger data 2                                      â•‘
â•‘   0x7A3  TDATA3     Trigger data 3                                      â•‘
â•‘                                                                          â•‘
â•‘ 0xB00-0xB1F: Machine Performance Counters                               â•‘
â•‘   0xB00  MCYCLE     Machine cycle counter                               â•‘
â•‘   0xB01  MTIME      Machine time counter                                â•‘
â•‘   0xB02  MINSTRET   Machine instructions retired                        â•‘
â•‘   0xB03-0xB1F       Machine hardware performance counters               â•‘
â•‘                                                                          â•‘
â•‘ 0xC00-0xC1F: User-Readable Performance Counters (Shadows)               â•‘
â•‘   0xC00  CYCLE      Cycle counter (user read-only)                      â•‘
â•‘   0xC01  TIME       Time counter (user read-only)                       â•‘
â•‘   0xC02  INSTRET    Instructions retired (user read-only)               â•‘
â•‘   0xC03-0xC1F       User-readable performance counters                  â•‘
â•‘                                                                          â•‘
â•‘ 0xF00-0xF0F: Vendor-Specific CSRs                                       â•‘
â•‘   0xF00  VENDORID   Vendor identification                               â•‘
â•‘   0xF01  ARCHID     Architecture identification                         â•‘
â•‘   0xF02  IMPID      Implementation identification                       â•‘
â•‘   0xF03  HARTID     Hardware thread ID                                  â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Key CSR Descriptions
MSTATUS (0x300) - Machine Status Register
apache
Bit Field Layout (64 bits):

 63   62-34  33-32  31    30-23  22    21    20    19    18    17   
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ SD â”‚ res  â”‚ UXL â”‚TSR â”‚  res   â”‚TVM â”‚TW  â”‚TSR â”‚ resâ”‚MXR â”‚SUM â”‚res â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

 16-15  14-13  12-11  10-9   8     7     6     5     4     3     2-0
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ res â”‚ FS  â”‚  XS  â”‚ res â”‚MPIEâ”‚UBE â”‚SPIEâ”‚res â”‚UPIEâ”‚MIE â”‚SIE  â”‚UIE â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Fields:
  SD [63]:       State dirty (FP/vector state modified)
  UXL [33:32]:   User mode XLEN (00=32, 01=64, 10=128)
  TSR [22]:      Trap SRET (supervisor return instruction)
  TVM [20]:      Trap virtual memory (trap SATP writes)
  TW [21]:       Timeout wait (trap WFI in lower privilege)
  MXR [19]:      Make executable readable
  SUM [18]:      Supervisor user memory access
  FS [14:13]:    Floating-point state (00=off, 01=initial, 10=clean, 11=dirty)
  XS [12:11]:    Extension state
  MPIE [7]:      Machine prior interrupt enable
  UBE [6]:       User mode big-endian (0=little, 1=big)
  SPIE [5]:      Supervisor prior interrupt enable
  UPIE [4]:      User prior interrupt enable
  MIE [3]:       Machine interrupt enable (global)
  SIE [1]:       Supervisor interrupt enable
  UIE [0]:       User interrupt enable

Privilege Mode Encoding:

00: User mode (U)
01: Supervisor mode (S)
10: Reserved
11: Machine mode (M)

MTVEC (0x305) - Machine Trap Vector Base
excel
 63                                    2  1-0
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚          BASE (62 bits)              â”‚MODEâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Fields:
  BASE [63:2]:  Trap vector base address (16-byte aligned)
  MODE [1:0]:   Trap vector mode
                00 = Direct mode (all traps to BASE)
                01 = Vectored mode (interrupts to BASE + 4Ã—cause)
                10-11 = Reserved

Trap handling:
  Exception: PC = BASE
  Interrupt: PC = BASE + (4 Ã— exception_code)  [if MODE=01]

MCAUSE (0x342) - Machine Cause Register
 63    62                                  0
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚INT â”‚        EXCEPTION CODE (63 bits)      â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Fields:
  INT [63]:           1 = Interrupt, 0 = Exception
  EXCEPTION CODE:     Exception/interrupt type

Exception Codes:

sql_more
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ EXCEPTION CODE    DESCRIPTION                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ 0x00              Instruction address misaligned                   â•‘
â•‘ 0x01              Instruction access fault                         â•‘
â•‘ 0x02              Illegal instruction                              â•‘
â•‘ 0x03              Breakpoint                                       â•‘
â•‘ 0x04              Load address misaligned                          â•‘
â•‘ 0x05              Load access fault                                â•‘
â•‘ 0x06              Store/AMO address misaligned                     â•‘
â•‘ 0x07              Store/AMO access fault                           â•‘
â•‘ 0x08              Environment call from U-mode                     â•‘
â•‘ 0x09              Environment call from S-mode                     â•‘
â•‘ 0x0A              Reserved                                         â•‘
â•‘ 0x0B              Environment call from M-mode                     â•‘
â•‘ 0x0C              Instruction page fault                           â•‘
â•‘ 0x0D              Load page fault                                  â•‘
â•‘ 0x0E              Reserved                                         â•‘
â•‘ 0x0F              Store/AMO page fault                             â•‘
â•‘ 0x10-0x3F         Reserved for future standard use                 â•‘
â•‘ 0x40-0x7F         Reserved for vendor extensions                   â•‘
â•‘                                                                    â•‘
â•‘ Interrupt Codes (when INT=1):                                     â•‘
â•‘ 0x00              User software interrupt                          â•‘
â•‘ 0x01              Supervisor software interrupt                    â•‘
â•‘ 0x03              Machine software interrupt                       â•‘
â•‘ 0x04              User timer interrupt                             â•‘
â•‘ 0x05              Supervisor timer interrupt                       â•‘
â•‘ 0x07              Machine timer interrupt                          â•‘
â•‘ 0x08              User external interrupt                          â•‘
â•‘ 0x09              Supervisor external interrupt                    â•‘
â•‘ 0x0B              Machine external interrupt                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SATP (0x180) - Supervisor Address Translation and Protection
ini
 63-60   59-44      43-0
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MODE â”‚   ASID   â”‚            PPN (Physical Page Number)      â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Fields:
  MODE [63:60]:     Translation mode
                    0000 = Bare (no translation)
                    1000 = Sv39 (3-level page table, 39-bit VA)
                    1001 = Sv48 (4-level page table, 48-bit VA)
                    1010 = Sv57 (5-level page table, 57-bit VA)
                    1011 = Sv64 (5-level page table, 64-bit VA)
  ASID [59:44]:     Address space identifier (16 bits)
  PPN [43:0]:       Physical page number of root page table

Page Table Modes:

apache
Sv39: 512 GB virtual address space
      3-level page table (9+9+9+12 bit split)
      
Sv48: 256 TB virtual address space
      4-level page table (9+9+9+9+12 bit split)
      
Sv57: 128 PB virtual address space
      5-level page table (9+9+9+9+9+12 bit split)

ğŸ”„ PIPELINE ARCHITECTURE
Superscalar Out-of-Order Pipeline
apache
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ SUPRAX Pipeline Stages (High-Performance Implementation)                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Stage 1-2: FETCH                                                         â•‘
â•‘   â€¢ 16-byte fetch per cycle (1 instruction)                             â•‘
â•‘   â€¢ I-Cache access (64 KB, 4-way)                                       â•‘
â•‘   â€¢ Branch prediction (hybrid predictor)                                â•‘
â•‘   â€¢ Return address stack (64 entries)                                   â•‘
â•‘   â€¢ Branch target buffer (2K entries)                                   â•‘
â•‘                                                                          â•‘
â•‘ Stage 3-4: DECODE                                                        â•‘
â•‘   â€¢ Instruction decode (up to 4 instructions)                           â•‘
â•‘   â€¢ Parallel ALU detection (DUAL/QUAD/TRIPLE)                           â•‘
â•‘   â€¢ Micro-op generation                                                 â•‘
â•‘   â€¢ Instruction queue (64 entries)                                      â•‘
â•‘                                                                          â•‘
â•‘ Stage 5-6: RENAME                                                        â•‘
â•‘   â€¢ Register renaming (256 arch â†’ 3072 physical)                        â•‘
â•‘   â€¢ Move elimination                                                    â•‘
â•‘   â€¢ Dependency tracking                                                 â•‘
â•‘   â€¢ Free list management                                                â•‘
â•‘   â€¢ Reorder buffer allocation (512 entries)                             â•‘
â•‘                                                                          â•‘
â•‘ Stage 7-8: DISPATCH                                                      â•‘
â•‘   â€¢ Reservation stations (96 total):                                    â•‘
â•‘     - 32 for integer ALU                                                â•‘
â•‘     - 24 for load/store                                                 â•‘
â•‘     - 16 for FP/SIMD                                                    â•‘
â•‘     - 12 for branch                                                     â•‘
â•‘     - 12 for special (CRYPTO/NEURAL)                                    â•‘
â•‘   â€¢ Out-of-order issue                                                  â•‘
â•‘   â€¢ Wakeup and select logic                                             â•‘
â•‘                                                                          â•‘
â•‘ Stage 9-12: EXECUTE (Multiple Parallel Units)                           â•‘
â•‘   Integer Cluster:                                                      â•‘
â•‘     â€¢ 8Ã— ALU units (1 cycle, DUAL/QUAD support)                         â•‘
â•‘     â€¢ 2Ã— Complex ALU (3 cycle, MUL/DIV)                                 â•‘
â•‘     â€¢ 2Ã— Branch units                                                   â•‘
â•‘   Load/Store Cluster:                                                   â•‘
â•‘     â€¢ 3Ã— AGU (Address Generation Units)                                 â•‘
â•‘     â€¢ 2Ã— Load ports (L1D access)                                        â•‘
â•‘     â€¢ 1Ã— Store port                                                     â•‘
â•‘   FP/SIMD Cluster:                                                      â•‘
â•‘     â€¢ 4Ã— FP ALU (FADD/FMUL, 4-5 cycle)                                  â•‘
â•‘     â€¢ 2Ã— FP FMA units (5 cycle)                                         â•‘
â•‘     â€¢ 1Ã— FP DIV/SQRT unit (15-28 cycle, not pipelined)                  â•‘
â•‘     â€¢ 2Ã— SIMD units (VALU)                                              â•‘
â•‘   Special Units:                                                        â•‘
â•‘     â€¢ 1Ã— CRYPTO unit (AES/SHA)                                          â•‘
â•‘     â€¢ 1Ã— NEURAL unit (DOT/CONV)                                         â•‘
â•‘     â€¢ 1Ã— BIT unit (POPCNT/CLZ/PDEP/PEXT)                                â•‘
â•‘                                                                          â•‘
â•‘ Stage 13-14: WRITEBACK                                                   â•‘
â•‘   â€¢ Result forwarding network                                           â•‘
â•‘   â€¢ Physical register file update                                       â•‘
â•‘   â€¢ Reorder buffer update                                               â•‘
â•‘                                                                          â•‘
â•‘ Stage 15: COMMIT/RETIRE                                                  â•‘
â•‘   â€¢ In-order commit (maintains precise exceptions)                      â•‘
â•‘   â€¢ Architectural register file update                                  â•‘
â•‘   â€¢ Free physical register                                              â•‘
â•‘   â€¢ Branch resolution                                                   â•‘
â•‘   â€¢ Exception handling                                                  â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Pipeline Width and Throughput
apache
Fetch Width:        1 instruction per cycle (16 bytes)
                    (limited by 128-bit instruction width)
                    
Decode Width:       4 micro-ops per cycle
                    (QUAD expands to 4 Î¼Ops)
                    
Issue Width:        12 micro-ops per cycle (out-of-order)

Execute Width:      Up to 20 operations per cycle
                    (8 ALU + 2 complex + 2 LD + 1 ST + 4 FP + 2 SIMD + 1 branch)

Commit Width:       8 micro-ops per cycle (in-order)

Reorder Buffer:     512 entries
Physical Registers: 3072 (integer + FP unified)
Reservation Stations: 96 total
Load Queue:         128 entries
Store Queue:        64 entries

ğŸ’¾ MEMORY SUBSYSTEM
Cache Hierarchy
dsconfig
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L1 Instruction Cache                                                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Size:              64 KB                                                â•‘
â•‘  Associativity:     4-way set-associative                                â•‘
â•‘  Line Size:         64 bytes                                             â•‘
â•‘  Latency:           3 cycles                                             â•‘
â•‘  Bandwidth:         16 bytes/cycle (1 instruction)                       â•‘
â•‘  Replacement:       Pseudo-LRU                                           â•‘
â•‘  Prefetch:          Next-line prefetcher                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L1 Data Cache                                                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Size:              64 KB                                                â•‘
â•‘  Associativity:     8-way set-associative                                â•‘
â•‘  Line Size:         64 bytes                                             â•‘
â•‘  Latency:           4 cycles (load-to-use)                               â•‘
â•‘  Bandwidth:         2 loads + 1 store per cycle (3 ports)                â•‘
â•‘  Write Policy:      Write-back, write-allocate                           â•‘
â•‘  Replacement:       Pseudo-LRU                                           â•‘
â•‘  Prefetch:          Stride prefetcher + stream prefetcher                â•‘
â•‘  MSHR:              16 miss-status holding registers                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L2 Cache (Private per core)                                             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Size:              512 KB                                               â•‘
â•‘  Associativity:     16-way set-associative                               â•‘
â•‘  Line Size:         64 bytes                                             â•‘
â•‘  Latency:           12 cycles                                            â•‘
â•‘  Bandwidth:         64 bytes/cycle                                       â•‘
â•‘  Write Policy:      Write-back, inclusive of L1                          â•‘
â•‘  Replacement:       Adaptive (pseudo-LRU with insertion policy)          â•‘
â•‘  Prefetch:          Multi-stride + region prefetcher                     â•‘
â•‘  MSHR:              32 entries                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L3 Cache (Shared, distributed slices)                                   â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Size:              32 MB (total, 2 MB per slice Ã— 16 slices)            â•‘
â•‘  Associativity:     16-way set-associative                               â•‘
â•‘  Line Size:         64 bytes                                             â•‘
â•‘  Latency:           35-50 cycles (depends on slice distance)             â•‘
â•‘  Bandwidth:         128 bytes/cycle (aggregate across slices)            â•‘
â•‘  Write Policy:      Write-back, non-inclusive                            â•‘
â•‘  Replacement:       RRIP (Re-Reference Interval Prediction)              â•‘
â•‘  Directory:         Snooping protocol (MESI/MOESI)                       â•‘
â•‘  Hashing:           Address hashing for slice distribution               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TLB (Translation Lookaside Buffer) Hierarchy
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L1 ITLB (Instruction)                                                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Entries:           128 (fully associative)                              â•‘
â•‘  Page Sizes:        4 KB, 2 MB, 1 GB                                     â•‘
â•‘  Latency:           0 cycles (parallel with I-Cache)                     â•‘
â•‘  Replacement:       LRU                                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L1 DTLB (Data)                                                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Entries:           128 (fully associative)                              â•‘
â•‘  Page Sizes:        4 KB, 2 MB, 1 GB                                     â•‘
â•‘  Latency:           0 cycles (parallel with D-Cache)                     â•‘
â•‘  Replacement:       LRU                                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ L2 TLB (Unified)                                                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Entries:           2048 (8-way set-associative)                         â•‘
â•‘  Page Sizes:        4 KB, 2 MB, 1 GB                                     â•‘
â•‘  Latency:           8 cycles (on L1 TLB miss)                            â•‘
â•‘  Replacement:       Pseudo-LRU                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Page Walk Latency:    20-100 cycles (on L2 TLB miss, depends on page table depth)
Page Table Support:   Sv39, Sv48, Sv57 (3/4/5-level page tables)

ğŸ§® EXECUTION UNIT DETAILS
Integer ALU Cluster
mipsasm
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 8Ã— Simple ALU Units                                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, CMP              â•‘
â•‘  Latency:       1 cycle                                                  â•‘
â•‘  Throughput:    1 op/cycle per unit                                      â•‘
â•‘  Total:         8 ops/cycle (if all 8 units busy)                        â•‘
â•‘  Supports:      DUAL (2 ops), QUAD (4 ops), TRIPLE (3 ops)              â•‘
â•‘  Forwarding:    Full bypass network                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 2Ã— Complex ALU Units                                                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    MUL, MULH, MULHU, MULHSU (3 cycles)                     â•‘
â•‘                 DIV, DIVU, REM, REMU (18 cycles, not pipelined)          â•‘
â•‘  Throughput:    MUL: 1 op/cycle (pipelined)                              â•‘
â•‘                 DIV: 1 op/18 cycles (serialized)                         â•‘
â•‘  Total MUL:     2 per cycle                                              â•‘
â•‘  Total DIV:     1 every 18 cycles (blocks unit)                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 2Ã— Branch Units                                                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    BR, JMP, CALL, RET, JMPR, CALLR                         â•‘
â•‘  Latency:       1 cycle (predicted correctly)                            â•‘
â•‘                 15-20 cycles (mispredicted, full flush)                  â•‘
â•‘  Prediction:    Hybrid predictor (TAGE + perceptron)                     â•‘
â•‘                 Accuracy: ~98% (typical workloads)                       â•‘
â•‘  BTB:           2048 entries, 4-way set-associative                      â•‘
â•‘  RAS:           64-entry return address stack                            â•‘
â•‘  Throughput:    2 branches/cycle (both predicted correctly)              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Load/Store Cluster
pgsql
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 3Ã— Address Generation Units (AGU)                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    Base + offset, Base + indexÃ—scale + offset              â•‘
â•‘  Latency:       1 cycle                                                  â•‘
â•‘  Throughput:    3 addresses/cycle                                        â•‘
â•‘  Supports:      LD, LDX, ST, STX operations                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 2Ã— Load Ports                                                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    LD (all sizes: 8/16/32/64-bit)                          â•‘
â•‘  Latency:       4 cycles (L1 hit, load-to-use)                          â•‘
â•‘                 12 cycles (L2 hit)                                       â•‘
â•‘                 35-50 cycles (L3 hit)                                    â•‘
â•‘                 100-300 cycles (DRAM)                                    â•‘
â•‘  Throughput:    2 loads/cycle (L1 hit)                                   â•‘
â•‘  Alignment:     Unaligned access supported (may cross cache line)        â•‘
â•‘  Forwarding:    Store-to-load forwarding (1 cycle penalty)               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 1Ã— Store Port                                                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    ST (all sizes: 8/16/32/64-bit)                          â•‘
â•‘  Latency:       1 cycle (to store buffer)                                â•‘
â•‘                 Actual memory write: 4+ cycles (asynchronous)            â•‘
â•‘  Throughput:    1 store/cycle                                            â•‘
â•‘  Store Buffer:  64 entries                                               â•‘
â•‘  Coalescing:    Consecutive stores may coalesce                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Memory Ordering                                                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Model:         Total Store Ordering (TSO) by default                    â•‘
â•‘                 Explicit FENCE for stricter ordering                     â•‘
â•‘  Load-Load:     Ordered (cannot reorder)                                 â•‘
â•‘  Load-Store:    Ordered                                                  â•‘
â•‘  Store-Store:   Ordered                                                  â•‘
â•‘  Store-Load:    Can be reordered (FENCE required if dependent)           â•‘
â•‘  Atomic Ops:    Sequentially consistent (no reordering across atomics)   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Floating-Point/SIMD Cluster
apache
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 4Ã— FP ALU Units (FADD/FMUL)                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    FADD, FSUB (4 cycles)                                    â•‘
â•‘                 FMUL (5 cycles)                                          â•‘
â•‘  Precision:     Single (32-bit), Double (64-bit)                         â•‘
â•‘  Throughput:    1 op/cycle per unit (fully pipelined)                    â•‘
â•‘  Total:         4 FP ops/cycle                                           â•‘
â•‘  Standards:     IEEE 754-2019 compliant                                  â•‘
â•‘  Rounding:      All 5 modes (nearest, toward 0, Â±âˆ, away from 0)        â•‘
â•‘  Denormals:     Hardware support (no performance penalty)                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 2Ã— FP FMA Units (Fused Multiply-Add)                                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    FPFMA (AÃ—B + C)                                          â•‘
â•‘  Latency:       5 cycles                                                 â•‘
â•‘  Throughput:    1 FMA/cycle per unit (pipelined)                         â•‘
â•‘  Total:         2 FMA/cycle = 4 FP ops/cycle (2 mul + 2 add)            â•‘
â•‘  Advantage:     Single rounding (more accurate than MUL+ADD)             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 1Ã— FP DIV/SQRT Unit                                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    FPDIV, FPSQRT                                            â•‘
â•‘  Latency:       Single: DIV=15, SQRT=18 cycles                           â•‘
â•‘                 Double: DIV=23, SQRT=28 cycles                           â•‘
â•‘  Throughput:    NOT pipelined (blocks unit for full latency)             â•‘
â•‘  Algorithm:     SRT division, Newton-Raphson refinement                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ 2Ã— SIMD Units (Vector ALU)                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    VALU (element-wise), VCMP, VSHUFFLE                      â•‘
â•‘  Element Width: 8/16/32/64-bit                                           â•‘
â•‘  Latency:       1-3 cycles (depends on operation)                        â•‘
â•‘  Throughput:    2-16 element ops/cycle (depends on width)                â•‘
â•‘  Vector FMA:    VFMA supported (4 cycles, 2Ã—32-bit or 1Ã—64-bit)          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Special Purpose Units
apache
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ CRYPTO Unit                                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    AES-128/192/256 (encrypt/decrypt)                        â•‘
â•‘                 SHA-256, SHA-512                                         â•‘
â•‘  Latency:       AES round: 3 cycles                                      â•‘
â•‘                 SHA round: 5 cycles                                      â•‘
â•‘  Throughput:    1 op/cycle (pipelined)                                   â•‘
â•‘  Full AES-128:  30 cycles (10 rounds Ã— 3 cycles)                         â•‘
â•‘  Full SHA-256:  320 cycles (64 rounds Ã— 5 cycles)                        â•‘
â•‘  Side Channel:  Constant-time execution (resistant to timing attacks)    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ NEURAL Unit                                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    INT8 dot product (8-16 elements)                         â•‘
â•‘                 3Ã—3 convolution primitive                                â•‘
â•‘                 ReLU, Sigmoid activation                                 â•‘
â•‘                 Quantize/Dequantize                                      â•‘
â•‘  Latency:       DOT8: 5 cycles                                           â•‘
â•‘                 CONV3x3: 8 cycles                                        â•‘
â•‘  Throughput:    1 op/cycle (pipelined)                                   â•‘
â•‘  Peak TOPS:     Up to 128 INT8 ops/cycle (4 GHz Ã— 32 MACs)              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ BIT Manipulation Unit                                                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Operations:    POPCNT, CLZ, CTZ, BSWAP, BITREV                         â•‘
â•‘                 PDEP, PEXT, CRC                                          â•‘
â•‘  Latency:       Simple: 1-2 cycles                                       â•‘
â•‘                 Complex (PDEP/PEXT): 3 cycles                            â•‘
â•‘  Throughput:    1 op/cycle                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”€ REGISTER RENAMING
Register Rename Architecture
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ REGISTER RENAMING SUBSYSTEM                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Architectural Registers:  256 (r0-r255)                                 â•‘
â•‘ Physical Registers:       3072                                          â•‘
â•‘ Rename Ratio:             12:1                                          â•‘
â•‘                                                                          â•‘
â•‘ Free List:                Circular buffer of available physical regs     â•‘
â•‘   Size:                   3072 entries                                   â•‘
â•‘   Head/Tail Pointers:     12-bit                                        â•‘
â•‘                                                                          â•‘
â•‘ Register Alias Table (RAT):                                             â•‘
â•‘   Entries:                256 (one per architectural register)           â•‘
â•‘   Each Entry:             12-bit physical register number                â•‘
â•‘   Access:                 4 reads + 4 writes per cycle                   â•‘
â•‘                                                                          â•‘
â•‘ Reorder Buffer (ROB):                                                    â•‘
â•‘   Size:                   512 entries                                    â•‘
â•‘   Each Entry:             - Architectural dest register                  â•‘
â•‘                           - Physical dest register                       â•‘
â•‘                           - Old physical register (for rollback)         â•‘
â•‘                           - Completion status                            â•‘
â•‘                           - Exception info                               â•‘
â•‘                           - PC                                           â•‘
â•‘   Commit Width:           8 instructions per cycle (in-order)            â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Rename Example
apache
Original Code (Architectural Registers):
  1: ADD r10, r11 â†’ r12     ; r12 = r10 + r11
  2: SUB r12, r13 â†’ r14     ; r14 = r12 - r13  (WAR hazard on r12)
  3: MUL r12, r15 â†’ r16     ; r16 = r12 Ã— r15  (RAW on inst 1's r12)

After Renaming (Physical Registers):
  1: ADD p100, p101 â†’ p200  ; p200 = p100 + p101
  2: SUB p200, p102 â†’ p201  ; p201 = p200 - p102  (no hazard!)
  3: MUL p200, p103 â†’ p202  ; p202 = p200 Ã— p103  (no hazard!)

RAT Update Sequence:
  Before inst 1:  RAT[r10]=p100, RAT[r11]=p101, RAT[r12]=p150
  After inst 1:   RAT[r12]=p200 (new mapping)
  After inst 2:   RAT[r14]=p201
  After inst 3:   RAT[r16]=p202

All 3 instructions can execute in parallel (no false dependencies)!

ğŸ¯ BRANCH PREDICTION
Hybrid Branch Predictor
apache
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ TAGE Predictor (Tagged Geometric History Length)                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Components:      8 tables with increasing history lengths               â•‘
â•‘  History Lengths: 0, 2, 4, 8, 16, 32, 64, 128 branches                   â•‘
â•‘  Entries/Table:   4K entries (total 32K entries)                         â•‘
â•‘  Tag Width:       9-12 bits (depends on table)                           â•‘
â•‘  Counter Width:   3 bits (signed, -4 to +3)                              â•‘
â•‘  Prediction:      Longest matching history table wins                    â•‘
â•‘  Accuracy:        ~95-98% (typical)                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Perceptron Predictor (Neural Network)                                   â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Perceptrons:     2048 perceptrons                                       â•‘
â•‘  Weights:         64 weights per perceptron (7-bit each)                 â•‘
â•‘  History:         64-bit global history register                         â•‘
â•‘  Training:        Online learning (update on misprediction)              â•‘
â•‘  Accuracy:        ~96-99% (especially good for correlated branches)      â•‘
â•‘  Advantage:       Learns complex patterns, adapts to phase changes       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Meta-Predictor (Selector)                                                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Function:        Chooses between TAGE and Perceptron                    â•‘
â•‘  Entries:         4096 entries                                           â•‘
â•‘  Counter Width:   2 bits per entry                                       â•‘
â•‘  Logic:           Tracks which predictor is more accurate per branch     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Branch Target Buffer (BTB)                                               â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Entries:         2048 entries                                           â•‘
â•‘  Associativity:   4-way set-associative                                  â•‘
â•‘  Each Entry:      - Branch PC (tag)                                      â•‘
â•‘                   - Target address (64 bits)                             â•‘
â•‘                   - Branch type (conditional/unconditional/call/return)  â•‘
â•‘  Hit Rate:        >99% (typical)                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Return Address Stack (RAS)                                               â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Depth:           64 entries (circular buffer)                           â•‘
â•‘  Push:            On CALL/CALLR instruction                              â•‘
â•‘  Pop:             On RET instruction                                     â•‘
â•‘  Prediction:      Top-of-stack for RET target                            â•‘
â•‘  Accuracy:        >99.9% (return addresses highly predictable)           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Branch Misprediction Recovery
pgsql
Misprediction Penalty:  15-20 cycles
  - 3 cycles: Detect misprediction (in execute stage)
  - 2 cycles: Flush pipeline
  - 5 cycles: Correct RAT/ROB state (rollback renamed registers)
  - 3 cycles: Restart fetch from correct target
  - 5-7 cycles: Refill pipeline

Speculative State Management:
  - Checkpoint at each branch
  - Up to 32 simultaneous checkpoints
  - Instant rollback on misprediction
  - Free physical registers reclaimed on rollback

ğŸ§¬ INSTRUCTION ENCODING EXAMPLES
Example 1: Simple Arithmetic
asm
; Add two registers
ALU2.ADD r5, r6 â†’ r10, flags=1

Binary Encoding (128 bits):
  [127:122] Type = 0x08 (ALU2)                    = 001000
  [121:116] Operation = 0x00 (ADD)                = 000000
  [115:96]  Reserved                              = 00000000000000000000
  [95:88]   Rs1 = r5                              = 00000101
  [87:80]   Rs2 = r6                              = 00000110
  [79:72]   Rd = r10                              = 00001010
  [71:70]   FlagUpdate = 01                       = 01
  [69:0]    Reserved                              = (70 zeros)

Hexadecimal:
  0x08000000 00000506 0A400000 00000000

Example 2: Load with Offset
asm
; Load 64-bit value from memory
LD.64 [r20 + 0x1000] â†’ r10

Binary Encoding:
  [127:122] Type = 0x20 (LD)                      = 100000
  [121:113] Reserved                              = 000000000
  [112:110] Size = 011 (64-bit)                   = 011
  [109]     Sign = 0 (unsigned, N/A for 64-bit)   = 0
  [108:106] Ordering = 000 (normal)               = 000
  [105:96]  Reserved                              = 0000000000
  [95:88]   Rs_addr = r20                         = 00010100
  [87:80]   Rd_data = r10                         = 00001010
  [79:16]   Offset = 0x1000                       = (64-bit) 0x0000000000001000
  [15:0]    Reserved                              = 0000000000000000

Hexadecimal:
  0x80000000 00E0140A 00000000 00001000

Example 3: Dual Parallel ALU
asm
; Execute two operations in parallel
DUAL [ADD r5, r6 â†’ r10] [SUB r20, r21 â†’ r22], flags=A

Binary Encoding:
  [127:122] Type = 0x10 (DUAL)                    = 010000
  [121:116] Op A = 0x00 (ADD)                     = 000000
  [115:110] Op B = 0x01 (SUB)                     = 000001
  [109:98]  Reserved                              = 000000000000
  [97:96]   FlagSel = 01 (A updates flags)        = 01
  [95:88]   A:Rs1 = r5                            = 00000101
  [87:80]   A:Rs2 = r6                            = 00000110
  [79:72]   A:Rd = r10                            = 00001010
  [71:64]   B:Rs1 = r20                           = 00010100
  [63:56]   B:Rs2 = r21                           = 00010101
  [55:48]   B:Rd = r22                            = 00010110
  [47:0]    Reserved                              = (48 zeros)

Hexadecimal:
  0x40000100 01050 60A 14151600 00000000

Example 4: Branch Conditional
asm
; Branch if equal
BR.EQ 0x0000000000401000

Binary Encoding:
  [127:122] Type = 0x01 (BR)                      = 000001
  [121:118] Condition = 0x1 (EQ)                  = 0001
  [117:96]  Reserved                              = 0000000000000000000000
  [95:32]   Target = 0x0000000000401000           = (64-bit address)
  [31:0]    Reserved                              = 00000000000000000000000000000000

Hexadecimal:
  0x04400000 00000000 00000000 00401000

Example 5: Atomic Compare-And-Swap
asm
; CAS operation
CAS.64 r5, r6, [0x7FFF00001000] â†’ r10

Binary Encoding:
  [127:122] Type = 0x31 (CAS)                     = 110001
  [121:113] Reserved                              = 000000000
  [112:110] Size = 011 (64-bit)                   = 011
  [109:96]  Reserved                              = 00000000000000
  [95:88]   Rs_new = r5                           = 00000101
  [87:80]   Rs_cmp = r6                           = 00000110
  [79:72]   Rd_old = r10                          = 00001010
  [71:16]   Address = 0x7FFF00001000 (56-bit)     = 0x00007FFF00001000
  [15:0]    Reserved                              = 0000000000000000

Hexadecimal:
  0xC4000000 00E0050 60A007F FF00001000

ğŸ“š PROGRAMMING MODEL
Application Binary Interface (ABI)
armasm
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ REGISTER USAGE CONVENTION                                                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ r0          Zero register (hardwired to 0)                               â•‘
â•‘ r1          Return address / link register                               â•‘
â•‘ r2          Stack pointer (SP)                                           â•‘
â•‘ r3          Global pointer (GP)                                          â•‘
â•‘ r4          Thread pointer (TP)                                          â•‘
â•‘ r5-r7       Temporaries (caller-saved)                                   â•‘
â•‘ r8          Frame pointer (FP) / s0 (callee-saved)                       â•‘
â•‘ r9          Saved register s1 (callee-saved)                             â•‘
â•‘ r10-r17     Function arguments a0-a7 / return values                     â•‘
â•‘ r18-r27     Saved registers s2-s11 (callee-saved)                        â•‘
â•‘ r28-r31     Temporaries t3-t6 (caller-saved)                             â•‘
â•‘ r32-r63     Additional temporaries / local variables                     â•‘
â•‘ r64-r127    Callee-saved registers (preserved across calls)              â•‘
â•‘ r128-r255   Caller-saved / scratch registers                             â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ FUNCTION CALLING CONVENTION                                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Integer/Pointer Arguments:  r10-r17 (8 registers)                        â•‘
â•‘ FP Arguments:               r10-r17 (same registers, reused)             â•‘
â•‘ Return Values:              r10-r11 (2 registers, for 128-bit return)    â•‘
â•‘ Stack Arguments:            Passed on stack if >8 arguments              â•‘
â•‘                                                                          â•‘
â•‘ Stack Alignment:            16 bytes                                     â•‘
â•‘ Red Zone:                   128 bytes (leaf functions may use w/o adj SP)â•‘
â•‘                                                                          â•‘
â•‘ Callee Responsibilities:                                                 â•‘
â•‘   - Save r8-r9, r18-r27 if used                                          â•‘
â•‘   - Save r1 (return address) if making calls                             â•‘
â•‘   - Allocate/deallocate stack frame                                      â•‘
â•‘                                                                          â•‘
â•‘ Caller Responsibilities:                                                 â•‘
â•‘   - Save r5-r7, r28-r31, r128-r255 if needed across call                 â•‘
â•‘   - Pass arguments in r10-r17                                            â•‘
â•‘   - Adjust stack for >8 arguments                                        â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Function Prologue/Epilogue Example
asm
; Function with 3 local variables, calls other functions
my_function:
  ; Prologue
  ALUI.SUB r2, 64 â†’ r2, flags=0        ; Allocate stack frame (64 bytes)
  ST.64 r1 â†’ [r2 + 56]                 ; Save return address
  ST.64 r8 â†’ [r2 + 48]                 ; Save frame pointer
  MOV r2 â†’ r8                          ; Set up new frame pointer
  ST.64 r18 â†’ [r2 + 40]                ; Save callee-saved r18
  ST.64 r19 â†’ [r2 + 32]                ; Save callee-saved r19

  ; Function body
  ; ... use r10-r17 for arguments
  ; ... use r18, r19 for locals
  ; ... call other functions

  ; Epilogue
  LD.64 [r2 + 40] â†’ r18                ; Restore r18
  LD.64 [r2 + 32] â†’ r19                ; Restore r19
  LD.64 [r2 + 48] â†’ r8                 ; Restore frame pointer
  LD.64 [r2 + 56] â†’ r1                 ; Restore return address
  ALUI.ADD r2, 64 â†’ r2, flags=0        ; Deallocate stack frame
  RET r1                               ; Return

; Optimized with LDPAIR/STPAIR:
my_function_opt:
  ALUI.SUB r2, 64 â†’ r2, flags=0
  STPAIR r1, r8 â†’ [r2 + 48]            ; Save r1, r8 in one instruction
  MOV r2 â†’ r8
  STPAIR r18, r19 â†’ [r2 + 32]          ; Save r18, r19 in one instruction
  ; ... function body ...
  LDPAIR [r2 + 32] â†’ r18, r19          ; Restore r18, r19
  LDPAIR [r2 + 48] â†’ r1, r8            ; Restore r1, r8
  ALUI.ADD r2, 64 â†’ r2, flags=0
  RET r1

ğŸ” PERFORMANCE CHARACTERISTICS
Instruction Throughput Summary
apache
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ INSTRUCTION CLASS          LATENCY    THROUGHPUT      UNITS              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Integer ALU (ADD/SUB/LOG)  1 cycle    8/cycle         8Ã— ALU             â•‘
â•‘ Integer MUL                3 cycles   2/cycle         2Ã— Complex ALU     â•‘
â•‘ Integer DIV                18 cycles  1/18 cycles     2Ã— Complex ALU     â•‘
â•‘ Branch                     1 cycle    2/cycle         2Ã— Branch          â•‘
â•‘ Load (L1 hit)              4 cycles   2/cycle         2Ã— Load Port       â•‘
â•‘ Store                      1 cycle    1/cycle         1Ã— Store Port      â•‘
â•‘ FP ADD/SUB                 4 cycles   4/cycle         4Ã— FP ALU          â•‘
â•‘ FP MUL                     5 cycles   4/cycle         4Ã— FP ALU          â•‘
â•‘ FP FMA                     5 cycles   2/cycle         2Ã— FP FMA          â•‘
â•‘ FP DIV (SP/DP)             15/23 cyc  1/15-23 cyc     1Ã— FP DIV          â•‘
â•‘ FP SQRT (SP/DP)            18/28 cyc  1/18-28 cyc     1Ã— FP DIV          â•‘
â•‘ SIMD (VALU)                1-3 cycles 2-16 el/cycle   2Ã— SIMD            â•‘
â•‘ Atomic (AMO/CAS)           20-50 cyc  serialized      Memory Controller  â•‘
â•‘ CRYPTO (AES round)         3 cycles   1/cycle         1Ã— CRYPTO          â•‘
â•‘ NEURAL (DOT8)              5 cycles   1/cycle         1Ã— NEURAL          â•‘
â•‘ BIT (POPCNT/CLZ)           2-3 cycles 1/cycle         1Ã— BIT             â•‘
â•‘ DUAL                       max(A,B)   2/cycle         Multiple           â•‘
â•‘ QUAD                       op latency 4/cycle         Multiple           â•‘
â•‘ TRIPLE                     max(A,B,C) 3/cycle         Multiple           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Peak Performance Metrics
apache
Assumptions: 4 GHz clock, perfect ILP, no cache misses

Integer Operations:
  Simple ALU:         32 GOPS (8 units Ã— 4 GHz)
  Multiply:           8 GMUL/s (2 units Ã— 4 GHz)
  DUAL Throughput:    16 GOPS (8 ops via 4 DUAL instructions)
  QUAD Throughput:    16 GOPS (16 ops via 4 QUAD instructions)

Floating-Point:
  FP ADD/SUB:         16 GFLOPS (4 units Ã— 4 GHz)
  FP MUL:             16 GFLOPS (4 units Ã— 4 GHz)
  FP FMA:             32 GFLOPS (2 units Ã— 2 ops Ã— 4 GHz)
  Combined FMA:       32 GFLOPS (multiply) + 32 GFLOPS (add) = 64 GFLOPS

Memory:
  L1 Load Bandwidth:  64 GB/s (2 loads Ã— 8 bytes Ã— 4 GHz)
  L1 Store Bandwidth: 32 GB/s (1 store Ã— 8 bytes Ã— 4 GHz)
  Total L1 Bandwidth: 96 GB/s

Vector/SIMD (8-bit elements):
  VALU Throughput:    128 GOPS (2 units Ã— 8 elements Ã— 4 GHz)

Special:
  NEURAL (INT8 DOT8): 128 GTOPS (4 GHz Ã— 32 MACs per instruction)

ğŸ› EXCEPTION AND INTERRUPT HANDLING
Exception Types
mipsasm
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ SYNCHRONOUS EXCEPTIONS (Generated by Instructions)                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Instruction Address Misaligned:                                         â•‘
â•‘   - PC not 16-byte aligned                                               â•‘
â•‘   - Action: Trap to handler                                              â•‘
â•‘                                                                          â•‘
â•‘ Instruction Access Fault:                                                â•‘
â•‘   - TLB miss, protection violation, I-Cache parity error                 â•‘
â•‘   - Action: Trap, OS handles page fault or error                         â•‘
â•‘                                                                          â•‘
â•‘ Illegal Instruction:                                                     â•‘
â•‘   - Invalid opcode, reserved type, malformed encoding                    â•‘
â•‘   - Action: Trap, OS may emulate or terminate                            â•‘
â•‘                                                                          â•‘
â•‘ Breakpoint:                                                              â•‘
â•‘   - BREAK instruction executed                                           â•‘
â•‘   - Action: Trap to debugger                                             â•‘
â•‘                                                                          â•‘
â•‘ Load/Store Address Misaligned:                                           â•‘
â•‘   - Address not aligned to access size (if strict alignment required)    â•‘
â•‘   - Action: May complete slowly or trap (implementation-defined)         â•‘
â•‘                                                                          â•‘
â•‘ Load/Store Access Fault:                                                 â•‘
â•‘   - TLB miss, protection violation, D-Cache parity error                 â•‘
â•‘   - Action: Trap to OS                                                   â•‘
â•‘                                                                          â•‘
â•‘ Environment Call (SYSCALL):                                              â•‘
â•‘   - Intentional trap for system service                                  â•‘
â•‘   - Action: Transfer to supervisor/machine mode handler                  â•‘
â•‘                                                                          â•‘
â•‘ Load/Store Page Fault:                                                   â•‘
â•‘   - Page not present, copy-on-write, access violation                    â•‘
â•‘   - Action: Trap to OS, page fault handler                               â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ASYNCHRONOUS INTERRUPTS (External Events)                                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Timer Interrupt:                                                         â•‘
â•‘   - Programmable timer expires                                           â•‘
â•‘   - Use: OS scheduler, timekeeping                                       â•‘
â•‘                                                                          â•‘
â•‘ External Interrupt:                                                      â•‘
â•‘   - Device interrupt (I/O completion, network packet, etc.)              â•‘
â•‘   - Delivered via interrupt controller (vectored or polled)              â•‘
â•‘                                                                          â•‘
â•‘ Software Interrupt:                                                      â•‘
â•‘   - Inter-processor interrupt (IPI) for multi-core synchronization       â•‘
â•‘   - Use: TLB shootdown, scheduler IPI                                    â•‘
â•‘                                                                          â•‘
â•‘ Non-Maskable Interrupt (NMI):                                            â•‘
â•‘   - Critical events (machine check, parity error)                        â•‘
â•‘   - Cannot be disabled                                                   â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Exception Handling Sequence
sql_more
1. Exception Detected:
   - In execute stage (for synchronous exceptions)
   - At any time (for asynchronous interrupts)

2. Pipeline State:
   - Flush all younger instructions (squash speculative state)
   - Complete all older instructions (maintain precise exceptions)
   - Drain store buffer for memory exceptions

3. Save State:
   MEPC = PC of faulting instruction
   MCAUSE = exception code (with INT bit)
   MTVAL = additional info (faulting address, bad instruction bits)
   MSTATUS.MPIE = MSTATUS.MIE  (save interrupt enable state)
   MSTATUS.MIE = 0  (disable interrupts)
   MSTATUS.MPP = current_privilege_mode  (save privilege mode)

4. Enter Handler:
   current_privilege_mode = MACHINE_MODE (or delegated mode)
   PC = MTVEC.BASE + (MCAUSE Ã— 4)  [if vectored mode]
     or MTVEC.BASE  [if direct mode]

5. Handler Execution:
   - OS determines exception type from MCAUSE
   - Reads MEPC, MTVAL for context
   - Handles exception (page fault â†’ allocate page, syscall â†’ dispatch)
   - May kill process, emulate instruction, or resume execution

6. Return (ERET instruction):
   PC = MEPC  (return to faulting instruction or next)
   current_privilege_mode = MSTATUS.MPP  (restore privilege)
   MSTATUS.MIE = MSTATUS.MPIE  (restore interrupt enable)
   MSTATUS.MPIE = 1
   Resume execution

Latency: 50-200 cycles (exception) + handler time

ğŸ”’ SECURITY FEATURES
Memory Protection
pgsql
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHYSICAL MEMORY PROTECTION (PMP)                                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ PMP Entries:        16 regions (configurable)                            â•‘
â•‘ Granularity:        4 KB minimum                                         â•‘
â•‘ Modes:              OFF, TOR (top-of-range), NA4 (naturally aligned 4B), â•‘
â•‘                     NAPOT (naturally aligned power-of-2)                 â•‘
â•‘ Permissions:        R (read), W (write), X (execute)                     â•‘
â•‘ Lock Bit:           Prevents modification until reset                    â•‘
â•‘                                                                          â•‘
â•‘ Use Cases:                                                               â•‘
â•‘   - Protect machine-mode memory from supervisor/user                     â•‘
â•‘   - I/O device MMIO region protection                                    â•‘
â•‘   - Trusted execution environments                                       â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ VIRTUAL MEMORY PROTECTION (Page Tables)                                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Page Table Levels:  3-5 levels (Sv39/Sv48/Sv57)                          â•‘
â•‘ Page Sizes:         4 KB, 2 MB, 1 GB (superpages)                        â•‘
â•‘ Permissions:        R, W, X, U (user-accessible)                         â•‘
â•‘ Features:           - NX (No-Execute) enforcement                         â•‘
â•‘                     - ASLR (Address Space Layout Randomization)          â•‘
â•‘                     - COW (Copy-On-Write) support                        â•‘
â•‘                     - Accessed/Dirty bits                                â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ SPECULATIVE EXECUTION MITIGATIONS                                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                          â•‘
â•‘ Bounds Check Bypass (Spectre v1):                                        â•‘
â•‘   - Prediction barriers (FENCE.SYNC)                                     â•‘
â•‘   - Compiler mitigations (insert LFENCEs after array bounds checks)      â•‘
â•‘                                                                          â•‘
â•‘ Branch Target Injection (Spectre v2):                                    â•‘
â•‘   - Indirect branch prediction mode control (CSR)                        â•‘
â•‘   - Return stack buffer isolation across privilege levels                â•‘
â•‘   - BTB flushing on context switch                                       â•‘
â•‘                                                                          â•‘
â•‘ Rogue Data Cache Load (Meltdown):                                        â•‘
â•‘   - Hardware: Delay speculative loads across privilege check             â•‘
â•‘   - Software: Kernel page table isolation (KPTI)                         â•‘
â•‘                                                                          â•‘
â•‘ L1TF/MDS (Microarchitectural Data Sampling):                             â•‘
â•‘   - L1D cache flushing on privilege transitions                          â•‘
â•‘   - Store buffer/fill buffer clearing                                    â•‘
â•‘   - Disable hyperthreading in sensitive environments                     â•‘
â•‘                                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“˜ ASSEMBLY LANGUAGE SYNTAX
Syntax Conventions
less
General Format:
  INSTRUCTION[.modifiers] operands â†’ destination[, flags=FLAG]

Modifiers:
  .size     - Data size (8/16/32/64 for memory ops)
  .sign     - Sign extension (S/U for signed/unsigned)
  .order    - Memory ordering (ACQ/REL/ACQ_REL/SEQ_CST)
  .cond     - Branch condition (EQ/NE/LT/GE/etc.)
  .prec     - FP precision (SP/DP for single/double)
  .op       - Operation type (for composite instructions)

Operands:
  rN        - Register (r0-r255)
  #imm      - Immediate value (can be hex 0x..., decimal, or binary 0b...)
  [addr]    - Memory address (base + offset or absolute)
  label     - Branch/call target (assembler resolves to address)

Destination:
  â†’ rd      - Result goes to rd
  â†’ rd1,rd2 - Multiple destinations (LDPAIR/STPAIR)

Flags:
  flags=0   - Don't update flags
  flags=1   - Update flags
  flags=A/B/C - For multi-op instructions (DUAL/TRIPLE)

Example Programs
Example 1: Array Sum (Simple Loop)

asm
; int array_sum(int* arr, int len)
; r10 = array pointer, r11 = length
; Returns sum in r10

array_sum:
  MOVI 0 â†’ r12                    ; sum = 0
  MOVI 0 â†’ r13                    ; i = 0
  
loop:
  CMP.SUB r13, r11                ; Compare i vs len
  BR.GE end                       ; if (i >= len) goto end
  
  LDX.32 [r10 + r13Ã—4] â†’ r14      ; r14 = arr[i]
  ALU2.ADD r12, r14 â†’ r12, flags=0 ; sum += arr[i]
  ALUI.ADD r13, 1 â†’ r13, flags=1  ; i++, update flags for next compare
  
  JMP loop                        ; goto loop
  
end:
  MOV r12 â†’ r10                   ; return sum
  RET r1

Example 2: Array Sum (Optimized with QUAD)

asm
; Optimized version using QUAD for 4-way parallelism
array_sum_opt:
  MOVI 0 â†’ r12                    ; sum = 0
  MOVI 0 â†’ r13                    ; i = 0
  ALUI.SUB r11, 3 â†’ r15, flags=0  ; len_minus_3 = len - 3 (for 4-way loop)
  
loop_quad:
  CMP.SUB r13, r15                ; Compare i vs (len-3)
  BR.GE loop_remainder            ; if (i >= len-3) goto scalar cleanup
  
  ; Load 4 elements in parallel
  LDQUAD [r10 + r13Ã—4] â†’ r20, r21, r22, r23
  
  ; Add all 4 to accumulator in parallel using QUAD
  QUAD.ADD [r12,r20â†’r12] [r12,r21â†’r12] [r12,r22â†’r12] [r12,r23â†’r12], flags=0
  
  ALUI.ADD r13, 4 â†’ r13, flags=1  ; i += 4
  JMP loop_quad
  
loop_remainder:
  ; Handle remaining 0-3 elements
  CMP.SUB r13, r11
  BR.GE end
  
  LDX.32 [r10 + r13Ã—4] â†’ r14
  ALU2.ADD r12, r14 â†’ r12, flags=0
  ALUI.ADD r13, 1 â†’ r13, flags=1
  JMP loop_remainder
  
end:
  MOV r12 â†’ r10
  RET r1

Example 3: Atomic Counter Increment

asm
; Atomically increment counter at address r10
; Returns old value in r10

atomic_increment:
  MOVI 1 â†’ r5                     ; increment value = 1
  
retry:
  LL.64 [r10] â†’ r11               ; Load-linked: r11 = *r10
  ALUI.ADD r11, 1 â†’ r12, flags=0  ; r12 = r11 + 1
  SC.64 r12, [r10] â†’ r13          ; Store-conditional: *r10 = r12 if exclusive
  CMP.SUB r13, r0                 ; Check if SC succeeded (r13 == 0)
  BR.NE retry                     ; Retry if failed
  
  MOV r11 â†’ r10                   ; Return old value
  RET r1

; Alternative using AMO (simpler):
atomic_increment_amo:
  MOVI 1 â†’ r5
  AMO.ADD.64.SEQ_CST r5, [r10] â†’ r10  ; Atomically: old = *r10; *r10 += 1; return old
  RET r1

Example 4: Dot Product (SIMD + NEURAL)

asm
; float dot_product(float* a, float* b, int len)
; r10 = a pointer, r11 = b pointer, r12 = length
; Returns dot product in r10 (FP)

dot_product:
  MOVI 0 â†’ r13                    ; accumulator = 0 (will convert to FP)
  FPCONV.I64_TO_FP64 r13 â†’ r13    ; accumulator = 0.0 (FP)
  MOVI 0 â†’ r14                    ; i = 0
  ALUI.SUB r12, 7 â†’ r15, flags=0  ; len_minus_7 = len - 7 (for 8-wide)
  
loop_neural:
  CMP.SUB r14, r15
  BR.GE loop_scalar
  
  ; Load 8 floats from each array (using LDQUAD twice)
  LDQUAD [r10 + r14Ã—4] â†’ r20, r21, r22, r23
  LDQUAD [r11 + r14Ã—4] â†’ r24, r25, r26, r27
  
  ; Use NEURAL.DOT8 for 8-way dot product (if INT8)
  ; For FP32, use vector FMA:
  VFMA.32 r20, r24, r13 â†’ r13     ; acc += a[i] * b[i] (2 elements)
  VFMA.32 r21, r25, r13 â†’ r13     ; acc += a[i+1] * b[i+1] (2 elements)
  ; ... continue for all 8 elements
  
  ALUI.ADD r14, 8 â†’ r14, flags=1
  JMP loop_neural
  
loop_scalar:
  ; Scalar cleanup for remaining elements
  CMP.SUB r14, r12
  BR.GE end
  
  LDX.32 [r10 + r14Ã—4] â†’ r20
  LDX.32 [r11 + r14Ã—4] â†’ r21
  FPFMA.DP r20, r21, r13 â†’ r13    ; acc += a[i] * b[i]
  ALUI.ADD r14, 1 â†’ r14, flags=1
  JMP loop_scalar
  
end:
  ; Horizontal reduction of vector accumulator
  VRED.SUM.32 r13 â†’ r10           ; Sum all FP elements into r10
  RET r1

This completes the SUPRAX ISA v8.2 Complete Specification. The architecture features:

128-bit fixed-width instructions for simplified decode
256 architectural registers with 3072 physical registers (register renaming)
Parallel execution support (DUAL/QUAD/TRIPLE instructions)
Rich memory operations (loads/stores with multiple sizes, atomic ops)
Hardware acceleration (CRYPTO, NEURAL, SIMD, bit manipulation)
High-performance pipeline (out-of-order superscalar, 15-stage)
Advanced branch prediction (hybrid TAGE + Perceptron)
Comprehensive security features (PMP, page tables, Spectre/Meltdown mitigations)
The ISA is designed for maximum throughput on both sequential and parallel workloads, with particular focus on scientific computing, AI/ML inference, cryptography, and general-purpose computing.